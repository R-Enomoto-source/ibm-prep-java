# LearningNote 2026-02-19

## セッションログ（ユーザー入力＋回答）

### switch式とswitch文での yield の要否
ユーザー: switch式ではyieldが必要でしたが、switch文ではどうですか？

アシスタント:
**switch式**と**switch文**の違いは次のとおりです。

#### switch式 → `yield` が必要

switch**式**は「値」を返すので、各分岐で **`yield`** でその値を返します。

```java
// switch式：yield で値を返す
String result = switch (x) {
    case 1 -> "one";
    case 2 -> {
        System.out.println("two");
        yield "two";  // ブロック内では yield が必須
    }
    default -> "other";
};
```

#### switch文 → `yield` は使わない

switch**文**は値は返さず、実行する処理を選ぶだけなので **`yield` は使いません**。  
分岐の終わりには **`break`**（またはフォールスルー）を使います。

```java
// switch文：break で case を抜ける
switch (x) {
    case 1:
        System.out.println("one");
        break;
    case 2:
        System.out.println("two");
        break;
    default:
        System.out.println("other");
}
```

#### まとめ

| 種類         | 役割       | 分岐の終わり |
|--------------|------------|--------------|
| **switch式** | 値を返す   | `yield`      |
| **switch文** | 処理の分岐 | `break`      |

つまり、**switch文では `yield` は使わず、`break` を使います。**

---

### 中括弧なしの複数行と while / do-while のコンパイルエラー
ユーザー: ｛｝なしで複数行コードを書く場合、while文ではコンパイルエラーにならず、do while文でコンパイルエラーになるのはなぜでしょうか？
while文は条件式の後の直後の1文だと読み取れるが、do while文はどの1行を繰り返せばよいかわかりづらいからだと思いましたがどうでしょうか？

アシスタント:
その理解で合っています。

**while文**では、条件の直後が「1文」と明確に決まるので、`{}` を省略したときも「その1文だけがループ本体」と解釈できます。

**do-while文**では、`do` のあとから `while(条件);` までがループ範囲なので、`{}` を省略すると「どの文までが do の本体か」が文法上はっきりしません。  
「どの1行を繰り返すかわかりづらい」ため、Javaでは do-while の本体に複数文を書く場合は `{}` が必須になり、省略するとコンパイルエラーになります。

---

### 2次元配列の構造の理解（array[0]、array.length、1次元目・2次元目）
ユーザー: array[0] → [ "A", "B", "C" ]
array.length == 1
array[0].length == 3
これが理解できていませんでした
{ {A,B,C},{} }
私が行っていた状況はこうですね

アシスタント: （この発言は理解の整理の共有のため、特段の回答は不要と判断しています。）

---

### 2次元配列で2つ目の要素が空の配列のときのコンパイルエラー
ユーザー: 下記はコンパイルエラーになりますよね？
{ { "A", "B", "C" }, { } }

アシスタント:
いいえ、**コンパイルエラーにはなりません**。

`{ { "A", "B", "C" }, { } }` は、

- 1つ目の要素: `{ "A", "B", "C" }` → 長さ3の String 配列  
- 2つ目の要素: `{ }` → 長さ0の String 配列（空配列）

の2つを持つ `String[][]` として有効な初期化子です。  
空配列 `{ }` も「初期化されている」とみなされるため、コンパイルは通ります。

---

### 2次元目が初期化されていないように見える理由と初期化の有無
ユーザー: 2次元目が初期化されていないように見えるのでコンパイルエラーになると思ったのですが、2時限目も初期化されているのでしょうか？

アシスタント:
はい。**2次元目も初期化されています**。

`String[][] array = { { "A", "B", "C" } };` のとき、

- **1次元目**: 要素が1つだけ → その1つが「1つの配列」です。
- **2次元目**: その1つの配列の中身が `"A"`, `"B"`, `"C"` の3要素で、きちんと初期化されています。

つまり「2次元目の配列が未初期化」ではなく、「2次元目の配列が1本だけあり、その中に3要素ある」状態なので、コンパイルエラーにはなりません。

---

### 2次元目が初期化されていない例の網羅
ユーザー: 2次元目が初期化されていない例を漏れなく教えてください

アシスタント:
2次元目（内側の配列）が初期化されていない例は、主に次のような場合です。

#### 1. 2次元目を new だけで確保した場合（参照のみ初期化）

```java
String[][] a = new String[2][];  // 2次元目は null のまま
// a[0], a[1] はどちらも null
```

#### 2. 1次元目だけ初期化子で指定し、2次元目を後で代入し忘れた場合

```java
String[][] b = new String[2][];
b[0] = new String[] { "A", "B" };
// b[1] は未代入 → null のまま（2次元目が「その行では」初期化されていない）
```

#### 3. 配列の一部の行だけ null にした場合

```java
String[][] c = { { "A" }, null };  // 2行目は「配列そのもの」が未初期化（null）
```

#### 4. 明示的に null を入れた場合

```java
String[][] d = new String[][] { new String[] { "A" }, null };
```

「2次元目が初期化されていない」＝「その行の配列参照が null か、まだ代入されていない」状態と考えると整理しやすいです。

---

### System.out.println(array) の表示内容（2次元配列）
ユーザー: これだと例えば
System.out.println(array);だったら
1
2
3
4
と表示されるのでしょうか？

アシスタント:
**いいえ、`1 2 3 4` のようには表示されません。**

`int[][] array = {{1, 2}, {3, 4}};` のとき、`System.out.println(array);` は **配列そのもの**（参照）を渡しています。  
配列には `toString()` がオーバーライドされていないため、Object のデフォルトの文字列表現（参照の種類とハッシュ値のようなもの、例: `[[I@15db9742]`）が出力されます。

`1` `2` `3` `4` を出したい場合は、要素をループで回して出力する必要があります。

```java
for (int[] row : array) {
    for (int n : row) {
        System.out.println(n);
    }
}
```

---

### 2次元配列を拡張for文で取り出す処理の説明
ユーザー: これはどういう処理ですか？（2次元配列を拡張for文で取り出す画像について）

アシスタント:
このコードは、**2次元配列の「行」を1本ずつ取り出して処理する**ための形です。

- `int[][] array = {{1, 2}, {3, 4}};`  
  - 2行・2列の2次元配列。  
  - `array[0]` が `{1, 2}`、`array[1]` が `{3, 4}` です。

- `for (int[] tmp : array)`  
  - 拡張forで `array` の要素を1つずつ取り出しています。  
  - 2次元配列の「要素」は1次元配列なので、`tmp` の型は `int[]` です。  
  - 1周目: `tmp` = `{1, 2}`  
  - 2周目: `tmp` = `{3, 4}`  

- `// do something`  
  - ここで、今の行 `tmp` に対して処理を書きます。  
  - 例えば、`tmp` の要素をさらに拡張forで回したり、合計を出したりします。

つまり「2次元配列の1次元目から1本ずつ配列を取り出し、その配列を `tmp` で受けている」処理です。

---

### 2つの2次元配列初期化は同じかどうか
ユーザー: String[][] array = { { "A", "B", "C" } };
String[][] array = { { "A", "B", "C" },{} };
上記2つは同じですか？

アシスタント:
**いいえ、同じではありません。**

- **1つ目** `{ { "A", "B", "C" } }`  
  - 1次元目が要素1つだけ。  
  - その1つが `{ "A", "B", "C" }`（長さ3の配列）。  
  - つまり `array.length == 1`、`array[0].length == 3` です。

- **2つ目** `{ { "A", "B", "C" }, { } }`  
  - 1次元目が要素2つ。  
  - 1つ目が `{ "A", "B", "C" }`、2つ目が `{ }`（長さ0の配列）。  
  - つまり `array.length == 2`、`array[0].length == 3`、`array[1].length == 0` です。

構造も要素数も違うので、別の配列です。

---

### String[][] に 1次元の初期化子を書いた場合（1次元配列かどうか）
ユーザー: これは1次元配列ということでしょうか？
String[][] array = { "A", "B", "C" };

アシスタント:
**いいえ。1次元配列ではなく、この書き方だとコンパイルエラーになります。**

`String[][]` は「String の配列」の配列なので、`{ }` の中には **String の配列**（`String[]`）を並べる必要があります。

`{ "A", "B", "C" }` は **String が3つ** 並んでいるだけなので、型は `String[]` であり、`String[][]` の1つ要素としては型が合いません。  
そのため、この初期化子は「型が一致しない」としてコンパイルエラーになります。

「1次元配列」にしたい場合は、次のように1次元で宣言します。

```java
String[] array = { "A", "B", "C" };
```

---

### String[][] array = { { "A", "B", "C" } }; がコンパイルエラーにならない理由
ユーザー: String[][] array = { { "A", "B", "C" } };がコンパイルエラーにならないのは何故ですか？

アシスタント:
**「1次元目に配列が1つあり、その配列の中身（2次元目）もきちんと初期化されている」からです。**

- `String[][]` は「String の配列を要素に持つ配列」です。  
- 外側の `{ }` は、その「配列の配列」の初期化子です。  
- その中に書かれている `{ "A", "B", "C" }` は、**1本の String 配列**（要素が "A", "B", "C" の3つ）です。  
- つまり「1次元目に要素が1つ」「その1つが長さ3の String 配列で、2次元目も初期化済み」なので、型も初期化の仕方も問題なく、コンパイルエラーにはなりません。

---

### 拡張forのループ変数と値渡し（str に代入しても配列が変わらない理由）
ユーザー: @Chapter3_questions.md (942-954) 
この配列では値渡しで値がstrに入っていると考えてよいですか？

アシスタント:
はい。Javaでは「参照の値渡し」なので、拡張forのループ変数には「参照のコピー」が入っていると考えてよいです。

#### 何が起きているか

- **プリミティブ（int など）**  
  ループ変数には「値そのもの」のコピーが入ります（いわゆる値渡し）。

- **参照型（String など）**  
  ループ変数には「参照（アドレス）のコピー」が入ります。  
  オブジェクト本体はコピーされず、同じインスタンスを指す別の参照が `str` に渡されます。

#### このコードの場合

```java
for (String str : array) {
    str = "D";  // str が指す先を "D" に変えているだけ
}
```

- `str` には、`array[i]` が持っている「参照のコピー」が入ります。
- `str = "D"` は「ローカル変数 `str` が指す先を "D" に変える」だけで、
  **配列の要素 `array[i]` が指している先は変わりません**。
- そのため配列の中身は "A", "B", "C" のままなので、表示は `ABC` になります。

#### まとめ

- 「値渡しで `str` に何かが入っている」という理解でよいです。
- ただし参照型のときに入るのは「オブジェクトのコピー」ではなく「参照のコピー」です。
- だから `str = "D"` は配列を書き換えず、`str` だけが別のオブジェクトを指すようになる、という動きになります。

---

### ラベルをつけられる箇所の具体例
ユーザー: ラベルをつけられる箇所の具体例を教えてください
ラベルは、ループに付けられることが多 くありますが、このほかにもさまざまな箇所に付けることができます。

コー ドブロック
すべてのループ文と分岐 (if、 switch)
式
代入
return文
tryブ ロック
throw文

アシスタント:
ラベルを付けられる箇所の具体例です。

#### 1. コードブロック

```java
public class Main {
    public static void main(String[] args) {
        BLOCK: {
            int x = 10;
            if (x > 5) {
                break BLOCK;  // ブロックを抜ける
            }
            System.out.println("これは表示されない");
        }
        System.out.println("ブロックの外");
    }
}
```

#### 2. ループ文（for, while, do-while）

```java
OUTER: for (int i = 0; i < 3; i++) {
    INNER: for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break OUTER;  // 外側のループを抜ける
        }
        System.out.println(i + "," + j);
    }
}
```

#### 3. 分岐（if文）

```java
IF_LABEL: if (condition) {
    if (anotherCondition) {
        break IF_LABEL;  // ifブロックを抜ける
    }
    System.out.println("これは表示されない場合がある");
}
```

#### 4. 分岐（switch文）

```java
SWITCH_LABEL: switch (value) {
    case 1:
        break SWITCH_LABEL;  // switchブロックを抜ける
    case 2:
        break;
}
```

#### 5. 式

```java
EXPR_LABEL: (x > 0 ? "positive" : "negative");
// 式にラベルを付けることはできますが、break/continue は使えません
```

#### 6. 代入

```java
ASSIGN_LABEL: int x = 10;
ASSIGN_LABEL2: String str = "Hello";
// 代入文にラベルを付けることができます
```

#### 7. return文

```java
public int method() {
    RETURN_LABEL: return 10;
    // return文にラベルを付けることができます
}
```

#### 8. tryブロック

```java
TRY_LABEL: try {
    int x = 10 / 0;
} catch (ArithmeticException e) {
    // tryブロックにラベルを付けることができます
} finally {
    // finallyブロックにもラベルを付けられます
}
```

#### 9. throw文

```java
THROW_LABEL: throw new RuntimeException("エラー");
// throw文にラベルを付けることができます
```

#### 実用的な例（ラベル付きbreak/continue）

```java
public class Main {
    public static void main(String[] args) {
        OUTER: for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (i == 1 && j == 1) {
                    continue OUTER;  // 外側のループの次の反復へ
                }
                if (i == 2 && j == 2) {
                    break OUTER;  // 外側のループを抜ける
                }
                System.out.println(i + "," + j);
            }
        }
    }
}
```

#### 注意点

- ラベルは多くの文・ブロックに付けられます。
- `break` や `continue` と組み合わせて使うのが一般的です。
- 式や代入にラベルを付けても、`break`/`continue` は使えません（ループやブロック内でのみ有効）。
- ラベルは通常、ネストしたループの制御で使います。

最も実用的なのは、ネストしたループで外側のループを制御する場合です。

---

### ラベル付き二重ループの動作（continue a / break b のトレース）
ユーザー: @Chapter3_questions.md (1109-1121) 
なぜ最初のループが2回目のループで止まっていて３回目のループ以降が飛ばされているのでしょうか？

アシスタント:
このコードは「2回目で止まって3回目以降が飛ばされる」のではなく、**外側のループ（i）は5回すべて実行**されます。動作を追跡します。

#### 動作の詳細な追跡

```java
int total = 0;
a: for (int i = 0; i < 5; i++) {           // i = 0, 1, 2, 3, 4 の5回実行
    b: for (int j = 0; j < 5; j++) {
        if (i % 2 == 0) continue a;        // iが偶数の場合、外側ループの次へ
        if (3 < j) break b;                 // j > 3 の場合、内側ループを抜ける
        total += j;
    }
}
```

#### 各反復の動作

**i = 0（偶数）:**
- `i % 2 == 0` が true → `continue a;` が実行
- 内側ループ（j）は実行されず、**i = 1 へ進む**

**i = 1（奇数）:**
- `i % 2 == 0` は false → 内側ループが実行される
- j = 0: `3 < 0` は false → `total += 0` → total = 0
- j = 1: `3 < 1` は false → `total += 1` → total = 1
- j = 2: `3 < 2` は false → `total += 2` → total = 3
- j = 3: `3 < 3` は false → `total += 3` → total = 6
- j = 4: `3 < 4` は true → `break b;` で内側ループを抜ける
- **i = 2 へ進む**

**i = 2（偶数）:**
- `i % 2 == 0` が true → `continue a;` が実行
- 内側ループ（j）は実行されず、**i = 3 へ進む**

**i = 3（奇数）:**
- `i % 2 == 0` は false → 内側ループが実行される
- j = 0: `total += 0` → total = 6
- j = 1: `total += 1` → total = 7
- j = 2: `total += 2` → total = 9
- j = 3: `total += 3` → total = 12
- j = 4: `break b;` で内側ループを抜ける
- **i = 4 へ進む**

**i = 4（偶数）:**
- `i % 2 == 0` が true → `continue a;` が実行
- 内側ループ（j）は実行されず、**ループ終了**

#### 重要なポイント

1. 外側のループ（i）は 0, 1, 2, 3, 4 の5回すべて実行されます。
2. `continue a;` は「外側ループの次の反復へ」を意味します。ループ自体は止まりません。
3. 内側ループ（j）が実行されるのは i が奇数のとき（i = 1, 3）のみです。
4. `break b;` は内側ループだけを抜け、外側ループは続行します。

#### 結果

- total = 0 + 1 + 2 + 3 + 0 + 1 + 2 + 3 = **12**

「2回目で止まる」のではなく、**偶数の i では内側ループがスキップされ、奇数の i では内側ループが実行される**という動作です。
