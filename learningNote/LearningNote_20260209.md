# LearningNote 2026-02-09

## セッションログ（ユーザー入力＋回答）

### List が解決できないコンパイルエラーの意味

ユーザー: List cannot be resolved to a typeJava(16777218)
意味だけ教えてください

アシスタント: **「List cannot be resolved to a type」** の意味は、

**コンパイラが `List` という型を認識できていない**ということです。

現在、`ArrayList` の `import` はありますが、`List` の `import` がありません。  
`List` は `java.util.List` にあるので、この型を使うには

```java
import java.util.List;
```

を追加する必要があります。

変数宣言で `List<Hero>` と書いているのに、`List` の定義（`import`）がないため「List が解決できない」エラーになっています。

### private フィールドにアクセスできないエラーの意味

ユーザー: The field Hero.name is not visibleJava(33554503)
意味だけ教えてください

アシスタント: **「The field Hero.name is not visible」** の意味は、

**`Hero` クラスの `name` フィールドに、そのクラスの外からアクセスできない**ということです。

`Hero` では `name` が `private` になっているため、`NameDisplay` などの他のクラスから `hero.name` のように直接参照できません。

この場合は、`Hero` に用意されている `getName()` を使う必要があります。

```java
hero.getName()  // ○ アクセス可能
hero.name       // × エラー（private なので不可）
```

### Map のキーを拡張 for 文で取得する書き方

ユーザー: for(String key:)
となっているのは、こうすることでhNameAndNum に入っているString型のkeyを取得できるからですか？

アシスタント: はい、その理解で合っています。

- **`hNameAndNum.keySet()`** が、マップに入っている**キーだけ**の集合（`Set<String>`）を返します。
- **`for (String key : hNameAndNum.keySet())`** は、そのキー集合の要素を1つずつ `key` に代入してループします。

なので、

- `key` の型を **`String`** にしているのは、「このマップのキーが String 型だから」です。
- `keySet()` を使っているのは、「キー一覧を取得して、そのキーでループしたいから」です。

ループ内では、その `key` で `hNameAndNum.get(key)` とすれば、対応する値（人口など）を取得できます。

### 間違いの詳細解説とどうしたら間違えないか

ユーザー: 解説やどうしたら間違えないかを分かりやすく詳細に解説
それを下記書式に従って、2026/02/09のLearningNoteに記載してください
（以下、書式・条件・記載ルールの説明）

アシスタント:

#### 1. 練習16-2で「Hero を ArrayList に格納」を間違えないために

##### 何が求められていたか
問題文は「2人の勇者(斎藤、鈴木)を**Heroとしてインスタンス化して ArrayList に格納**し、1人ずつ順番に取り出して名前を表示する」です。  
ここで**格納するもの**は「勇者の名前（String）」ではなく「**Hero 型のオブジェクト**」です。

##### なぜ `List<String>` だとずれるか
- 問題のねらいは「**コレクションにオブジェクトを入れて、取り出して使う**」練習です。
- 名前だけを `List<String>` に入れると、**Hero インスタンスはコレクションの外**にあり、リストには「文字列」しか入っていません。  
  そのため「ArrayList にオブジェクトを格納する」という題意を満たしていません。
- また、後で「勇者ごとに体力や装備を持たせる」などに広げるとき、**リストに入っているのが Hero なら**そのまま拡張できますが、String だけだと「どの勇者か」の情報がリストからは分からず、設計がやりづらくなります。

##### 正しい書き方のイメージ
- リストの型は **`List<Hero>`** にします。
- 格納するのは **`hero1`** と **`hero2`**（Hero のインスタンス）です。
- 取り出すときはループ変数を **`Hero h`** にして、**`h.getName()`** で名前を表示します。

```java
List<Hero> heroes = new ArrayList<>();
heroes.add(hero1);
heroes.add(hero2);
for (Hero h : heroes) {
    System.out.println(h.getName());
}
```

##### 間違えないためのポイント
- 問題文の「〇〇を格納」の **〇〇** を必ず確認する（ここでは「Hero」）。
- 「名前を表示する」だけを見て「名前だけあればいい」と判断せず、「何を格納するか」で型を決める。
- 書籍の「ArrayList にオブジェクトを入れる」サンプルでは、**入れる型とリストの型が一致している**ことを意識する。

##### 変数名の typo（dispay）について
- **display** は「表示する」の意味で、**i が2つ**です。  
-  IDE の補完（display と打って候補を選ぶ）や、メソッド名を `getDisplayName()` など既存の単語に合わせておくと typo を防ぎやすいです。

---

#### 2. 練習16-3で「勇者と倒した敵の数をペアで」を間違えないために

##### 何が求められていたか
問題文は「それぞれの**勇者が倒した敵の数(3、7)と勇者をペアで**コレクションに格納してください」です。  
つまり「**勇者（Hero）**」と「**倒した敵の数（Integer）**」をペアにしたコレクションが想定されています。  
解答例では **`Map<Hero, Integer>`**（キー：勇者、値：倒した敵の数）です。

##### なぜ `Map<String, Integer>` だとずれるか
- 問題のねらいは「**Map のキーにオブジェクト（Hero）を使う**」練習です。
- 名前（String）をキーにすると、**同じ名前の勇者が複数いると区別できない**・「キーはオブジェクト」という Map の使い方の練習にならない、という点で書籍の意図から外れます。
- 実際の設計でも「人やモノをキーにする」場合は、**オブジェクトをキー**にすることが多く、名前（String）は表示用に `key.getName()` で取り出します。

##### 正しい書き方のイメージ
- Map の型は **`Map<Hero, Integer>`** にします。
- キーに **Hero インスタンス**、値に **倒した敵の数** を put します。
- ループでは **`heroes.keySet()`** でキー（Hero）を取り出し、**`key.getName()`** で名前、**`heroes.get(key)`** で倒した敵の数を取得して表示します。

```java
Map<Hero, Integer> heroes = new HashMap<>();
heroes.put(hero1, 3);
heroes.put(hero2, 7);
for (Hero key : heroes.keySet()) {
    int value = heroes.get(key);
    System.out.println(key.getName() + "が倒した敵＝" + value);
}
```

（Hero クラスは問題のとおり `name` だけ持つ形でよいです。倒した敵の数は Map の「値」として持たせます。）

##### 間違えないためのポイント
- 「〇〇と〇〇をペアで」の **前半（キー側）が何か** を確認する（ここでは「勇者」＝ Hero オブジェクト）。
- Map は「キー → 値」の対応なので、「キーに何を、値に何を入れるか」を問題文と照らして決める。
- 解答解説の **`Map<Hero, Integer>`** のように、キーがクラス型になっている例を押さえておく。

##### 表示文言について
- 問題の出力例は「**斎藤が倒した敵=3**」です。  
  「が倒した**敵**=」と「が倒した**数**=」は意味は近いですが、**問題の文言に合わせる**と採点・自己確認しやすくなります。
- 等号は問題では全角「＝」なので、可能なら **全角「＝」** に合わせておくとよいです。

##### メソッド名の typo（getKilleEnemyNum）について
- **Killed** は「倒した」の意味で、**kill の過去形は killed**（l が2つ）です。  
  **Kille** は l が1つ足りない typo です。
- メソッド名は **getKilledEnemyNum** のように、英単語のスペルを確認するか、IDE の補完で既存の単語（killed）を選ぶと防げます。

---

#### 3. 共通して間違えないための心がけ

- **問題文の主語・目的語を押さえる**  
  「何を」「どこに」格納するかで、コレクションの型（`List<Hero>` か `List<String>` か、`Map<Hero, Integer>` か `Map<String, Integer>` か）が決まります。
- **解答解説の型を確認する**  
  解説に `List<Hero>` や `Map<Hero, Integer>` と書いてあれば、**オブジェクトを格納・キーにする**意図だと理解できます。
- **単語のスペルは IDE や辞書で確認する**  
  display / killed など、よく使う単語は typo するとバグの原因になるので、メソッド名・変数名では特に注意する。

### throw と throws の基本と違い（Java 例外処理）

ユーザー: throwとthrowsの基本と違いを分かりやすく一つ一つ丁寧に教えてください

アシスタント: Java の **throw** と **throws** の基本と違いを整理して説明します。

---

#### 1. 役割の違い（一言で）

| キーワード | 役割 |
|-----------|------|
| **throw** | 「ここで例外を発生させる」と**書く**（実行時に例外を投げる） |
| **throws** | 「このメソッドはこの例外を投げる可能性がある」と**宣言する**（メソッドのシグネチャに書く） |

---

#### 2. throw（例外を「投げる」）

**throw** は「この行で例外を発生させる」ときに使います。

- **書く場所**: メソッドの**中身（ブロック内）**
- **使い方**: `throw new 例外クラス名(...);`

```java
public void setAge(int age) {
    if (age < 0 || age > 150) {
        throw new IllegalArgumentException("年齢は0〜150の範囲で指定してください");
    }
    this.age = age;
}
```

- `throw` が実行されると、その時点で例外が発生し、通常の処理の流れが止まります。
- 呼び出し元で `try-catch` していなければ、そのまま上位に伝播します。

---

#### 3. throws（例外を「投げる可能性がある」と宣言する）

**throws** は「このメソッドは、指定した種類のチェック例外を投げる可能性がある」と**宣言**するときに使います。

- **書く場所**: メソッドの**宣言（シグネチャ）**の後ろ
- **使い方**: `戻り値の型 メソッド名(...) throws 例外クラス1, 例外クラス2 { ... }`

```java
// 「このメソッドは IOException を投げる可能性がある」という宣言
public void readFile(String path) throws IOException {
    FileReader fr = new FileReader(path);  // IOException が発生しうる
    // ...
}
```

- **チェック例外**（例: `IOException`, `SQLException`）は、メソッド内で発生しうるなら、原則として `throws` で宣言する必要があります。
- 宣言しておくことで、「呼び出し元はこの例外を catch するか、さらに throws で伝播させる必要がある」とコンパイラがチェックしてくれます。

---

#### 4. 両方を使う例

メソッド内で **throw** で例外を投げ、そのメソッドの宣言で **throws** で「どんな例外を投げるか」を書くパターンです。

```java
// throws: 「このメソッドは MyException を投げる可能性がある」と宣言
public void validate(String name) throws MyException {
    if (name == null || name.isEmpty()) {
        // throw: ここで実際に例外を発生させる
        throw new MyException("名前を入力してください");
    }
}
```

- **throw** … メソッドの**中**で「例外を発生させる」処理
- **throws** … メソッドの**宣言**で「どんな例外を投げうるか」を書く

---

#### 5. 違いのまとめ

| 項目 | throw | throws |
|------|--------|--------|
| **意味** | 例外を「投げる」（発生させる） | 例外を「投げる可能性がある」と宣言する |
| **書く場所** | メソッドの**中**（ブロック内） | メソッドの**宣言**の後ろ |
| **文か宣言か** | 1つの**文**（`throw new ...;`） | **宣言の一部**（`throws 例外名`） |
| **数** | 1回の throw で投げる例外は1つ | カンマ区切りで複数書ける（`throws A, B`） |

---

#### 6. 呼び出し元での扱い

`throws` で宣言されたチェック例外は、呼び出し元で次のどちらかが必要です。

1. **try-catch で捕まえる**

```java
try {
    readFile("data.txt");
} catch (IOException e) {
    System.out.println("ファイル読み込みエラー: " + e.getMessage());
}
```

2. **自分も throws で宣言して、さらに上位に任せる**

```java
public void doSomething() throws IOException {
    readFile("data.txt");  // readFile が throws IOException なので、ここでも宣言
}
```

---

#### 7. 覚え方のコツ

- **throw** … 「throw = 投げる」→ **実際に例外を投げる文**（メソッドの中に書く）
- **throws** … 「throws = ～を投げる（可能性がある）」→ **メソッドの宣言に付ける「投げうる例外のリスト」**

「throw は実行する文」「throws は宣言の一部」と覚えると、役割の違いが分かりやすいです。

