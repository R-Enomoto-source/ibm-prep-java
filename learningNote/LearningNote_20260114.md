# Javaの var (型推論) の使用可能/不可能な場所

`var` は Java 10 で導入されたローカル変数の型推論機能です。コンパイル時に型が自動的に推論されます。

---

## ❌ 使えない場所

### 1. フィールド（インスタンス変数・クラス変数）

```java
// ❌ コンパイルエラー
private var field = "Hello";
```

### 2. メソッドのパラメータ

```java
// ❌ コンパイルエラー
public void method(var param) { }
```

### 3. メソッドの戻り値型

```java
// ❌ コンパイルエラー
public var getValue() { 
    return 10; 
}
```

### 4. コンストラクタのパラメータ

```java
// ❌ コンパイルエラー
public MyClass(var param) { }
```

### 5. nullで初期化

型が推論できないため、`null`で初期化することはできません。

```java
// ❌ コンパイルエラー
var value = null;
```

### 6. 初期化子なしの宣言

`var`を使用する場合は、必ず初期化子が必要です。

```java
// ❌ コンパイルエラー
var value;
value = 10;
```

### 7. 配列の宣言（初期化子なし）

```java
// ❌ コンパイルエラー
var array;
array = new int[5];
```

### 8. 複数変数の同時宣言

`var`は複数の変数を一度に宣言する場合に使用できません。

```java
// ❌ コンパイルエラー
var a = 1, b = 2;
```

### 9. ラムダ式のパラメータ（Java 10では不可）

```java
// ❌ Java 10ではエラー、Java 11以降は可能
var lambda = (var x) -> x * 2;
```

---

## ✅ 使える場所

### 1. ローカル変数（基本型）

```java
var number = 42;        // ✅ int型として推論
var price = 99.99;      // ✅ double型として推論
var letter = 'A';       // ✅ char型として推論
var flag = true;        // ✅ boolean型として推論
```

### 2. ローカル変数（参照型）

```java
var message = "Hello, World!";                    // ✅ String型として推論
var list = new java.util.ArrayList<String>();     // ✅ ArrayList<String>型として推論
```

### 3. 配列の初期化（配列初期化子付き）

```java
var numbers = new int[]{1, 2, 3, 4, 5};                    // ✅ int[]型として推論
var names = new String[]{"Alice", "Bob", "Charlie"};       // ✅ String[]型として推論
```

### 4. 配列の初期化（new演算子付き）

```java
var array = new int[10];  // ✅ int[]型として推論
```

### 5. オブジェクトのインスタンス化

```java
var date = new java.util.Date();                                    // ✅ Date型として推論
var map = new java.util.HashMap<String, Integer>();                 // ✅ HashMap<String, Integer>型として推論
```

### 6. メソッド呼び出しの戻り値

```java
var message = "Hello";
var length = message.length();        // ✅ int型として推論
var upperCase = message.toUpperCase(); // ✅ String型として推論
```

### 7. 型推論が複雑な場合でも使用可能

```java
var complexList = java.util.Arrays.asList(1, 2, 3, 4, 5);  // ✅ List<Integer>型として推論
```

### 8. forループのカウンタ変数

```java
for (var i = 0; i < 10; i++) {  // ✅ int型として推論
    System.out.println(i);
}
```

### 9. 拡張forループ（for-each）

```java
var numbers = new int[]{1, 2, 3, 4, 5};
for (var item : numbers) {  // ✅ int型として推論
    System.out.println(item);
}
```

### 10. try-with-resources文

```java
try (var reader = new java.io.BufferedReader(
        new java.io.FileReader("file.txt"))) {  // ✅ BufferedReader型として推論
    // 処理
} catch (Exception e) {
    e.printStackTrace();
}
```

### 11. catch節（Java 11以降）

```java
try {
    int result = 10 / 0;
} catch (var e) {  // ✅ Exception型として推論（Java 11以降）
    System.out.println("エラー: " + e.getMessage());
}
```

### 12. ラムダ式の変数

```java
var lambda = (int x) -> x * 2;  // ✅ 関数型インターフェースとして推論
var result = lambda.apply(5);   // ✅ int型として推論
```

### 13. メソッド参照

```java
var methodRef = System.out::println;  // ✅ 関数型インターフェースとして推論
```

### 14. 匿名クラス

```java
var runnable = new Runnable() {  // ✅ Runnable型として推論
    @Override
    public void run() {
        System.out.println("実行中");
    }
};
```

### 15. ジェネリック型の推論

```java
var genericList = new java.util.ArrayList<java.util.List<String>>();  // ✅ 複雑なジェネリック型も推論可能
```

### 16. 配列の配列

```java
var matrix = new int[3][3];  // ✅ int[][]型として推論
```

### 17. 型推論の確認例

```java
public static void demonstrateTypeInference() {
    var text = "Java";
    var number = 100;
    var list = new java.util.ArrayList<String>();
    
    // 実際の型を確認（実行時）
    System.out.println("text の型: " + text.getClass().getName());
    System.out.println("number の型: " + ((Object)number).getClass().getName());
    System.out.println("list の型: " + list.getClass().getName());
    
    // 注意: varはコンパイル時の型推論なので、
    // 実行時には通常の型と同じように動作します
}
```

---

## ⚠️ 注意事項とベストプラクティス

### ✅ 良い例: 型が明確な場合

```java
var name = "John";
var age = 25;
var users = new java.util.ArrayList<String>();
```

### ⚠️ 注意: 型が不明確な場合は明示的な型を使用

```java
// 悪い例: 何の型か分からない
// var data = getData();  // 戻り値の型が不明確

// 良い例: 型を明示
String data = getData();  // 型が明確
```

### ✅ 良い例: 長い型名を簡潔に

```java
var map = new java.util.HashMap<String, java.util.List<java.util.Map<String, Integer>>>();
// 上記は以下のように書くより簡潔:
// HashMap<String, List<Map<String, Integer>>> map = new HashMap<>();
```

### ⚠️ 注意: 可読性を損なう場合は避ける

```java
// 悪い例: 型が推論しにくい
// var result = process(transform(calculate(data)));

// 良い例: 中間変数に型を明示
Data processed = process(transform(calculate(data)));
```

---

## まとめ

- **`var`はローカル変数でのみ使用可能**
- **初期化子が必須**
- **コンパイル時に型が推論される（実行時のオーバーヘッドなし）**
- **可読性を考慮して使用する**
- **型が不明確な場合は明示的な型宣言を使用する**

---

# 数値リテラルのアンダースコア（_）

Javaにおける数値リテラルのアンダースコア（`_`）は、**「人間がコードを読む際の可読性を上げ、桁数の数え間違いなどのミスを防ぐため」**に存在します。  
プログラミング上の動作や数値そのものには一切影響を与えません。コンパイル時に無視されます。  
以下に「メリット」「具体的な使い方」「使用できないルール（注意点）」を整理します。

## 1. メリット：なぜ使うのか？

最大の利点は、**桁区切り（カンマ）の代わり**になることです。  
日常生活では「100万円」を 1,000,000 と書きますが、Javaのコード内でカンマ（,）は別の意味（引数の区切りなど）を持つため、数値の中に書くことができません。

- **アンダースコアなし:** `int value = 1000000000;`  
  - パッと見て「1億」なのか「10億」なのか判断しづらく、ゼロの数を数える必要があります。書き間違いや読み間違い（バグ）の原因になります。
- **アンダースコアあり:** `int value = 1_000_000_000;`  
  - ひと目で「10億（1,000,000,000）」だと分かります。

## 2. 具体的な使い方

基本的には、数字と数字の間であれば、どこにでも、いくつでも入れることができます。

### 大きな桁の整数

3桁ごとに区切るのが一般的です。

```java
long population = 7_800_000_000L; // 78億
```

### 小数（浮動小数点数）

小数部でも使用可能です。

```java
double pi = 3.141_592_653;
```

### 2進数や16進数（暗号資産やビット演算などで便利）

特にビットの塊（4ビットや8ビットごと）を見やすくするために重宝します。

```java
// 2進数（0bで始まる）
int bitMask = 0b0011_0101_1100_0001;

// 16進数（0xで始まる）
long hexBytes = 0xFFFF_0000_CAFE_BABE_L;
```

## 3. 注意点：使えない場所（コンパイルエラーになる場所）

「数字と数字の間」以外には置けません。以下の場所には配置できないルールになっています。

1. **数値の先頭と末尾**
   - `_100` (NG: 変数名とみなされる)
   - `100_` (NG)
2. **小数点の隣**
   - `3_.14` (NG)
   - `3._14` (NG)
3. **サフィックス（接尾辞）の隣**
   - `100_L` (NG: long型のL)
   - `3.14_f` (NG: float型のf)
4. **プレフィックス（接頭辞）の隣**
   - `0x_52` (NG: 16進数)
   - `0b_10` (NG: 2進数)

### コード例まとめ

```java
public class Main {
    public static void main(String[] args) {
        // 【OK】 正しい使い方
        int ok1 = 1_000_000;      // 100万
        double ok2 = 123_456.789;  // 小数点以上も区切れる
        
        // 連続して使うことも可能（あまりやりませんが文法上はOK）
        int ok3 = 1_______0;       // 値は10
        
        // 【NG】 コンパイルエラーになる例
        // int ng1 = _100;         // 先頭はダメ
        // int ng2 = 100_;         // 末尾はダメ
        // float ng3 = 3_.14F;     // 小数点の隣はダメ
        // long ng4 = 100_L;       // Lの隣はダメ
        
        System.out.println(ok1);   // 出力: 1000000
    }
}
```

## 結論

自分でコードを書くときは、**「ゼロが4つ以上続く場合」や「ビット列を扱う場合」に積極的に使う**と、自分も他人も読みやすいコードになります。

---

# フィールドとコンストラクタ

Javaにおける「フィールド」と「コンストラクタ」は、クラス（設計図）を作るための最も重要な2つの要素です。

一言で言うと、以下の役割分担があります。

- **フィールド**：そのモノが持つ**「情報（データ）」**
- **コンストラクタ**：そのモノが生み出される瞬間の**「初期設定（準備）」**

RPGゲームの「勇者（Hero）」を例にすると、非常にわかりやすくなります。

## 1. フィールドとは？（情報・ステータス）

フィールドとは、クラスブロック `{ }` の直下に宣言される変数のことです。そのオブジェクトが持っている**「属性」や「状態」**を保存するために使います。

RPGの勇者でいうと…
- 「名前」
- 「HP（体力）」
- 「装備している武器」

これら一つ一つを記憶する箱がフィールドです。

```java
public class Hero {
    // これがフィールドです
    String name;  // 名前を覚える箱
    int hp;       // 体力を覚える箱
}
```

## 2. コンストラクタとは？（誕生時の初期設定）

コンストラクタは、`new`を使ってオブジェクト（実体）が生成された瞬間に、自動的に1回だけ実行される特別な処理です。主に、上記の「フィールド」に最初の値を入れる（初期化する）ために使われます。

RPGの勇者でいうと…
「名前を決めて、HPを満タンにして、ゲームの世界に誕生させる処理」

### コンストラクタのルール

1. メソッド名がクラス名と同じであること
2. 戻り値の型（`void`や`int`など）を書かないこと

```java
public class Hero {
    String name;
    int hp;

    // これがコンストラクタです（クラス名と同じ名前）
    public Hero(String n) {
        this.name = n; // 渡された名前をフィールドにセット
        this.hp = 100; // HPを最初は100にセット
        System.out.println(this.name + "が誕生した！");
    }
}
```

## 3. 2つを組み合わせた全体の動き

実際にこれらがどう連携するか、コード全体で見ると理解が深まります。

### 設計図（Heroクラス）

```java
public class Hero {
    // 【1. フィールド】（勇者のデータ）
    String name;
    int hp;

    // 【2. コンストラクタ】（誕生時の準備）
    public Hero(String name) {
        this.name = name; // 引数で受け取った名前をセット
        this.hp = 100;    // HPは自動的に100からスタート
    }

    // （参考：勇者の行動）
    public void attack() {
        System.out.println(this.name + "は攻撃した！");
    }
}
```

### 実行用コード（Mainクラス）

```java
public class Main {
    public static void main(String[] args) {
        // newした瞬間、コンストラクタが動きます
        // "ミナト" という情報がコンストラクタに渡されます
        Hero h = new Hero("ミナト"); 

        // 結果、フィールドnameには"ミナト"、hpには100が入った状態でスタートできる
        System.out.println("名前：" + h.name); // 出力: 名前：ミナト
        System.out.println("HP：" + h.hp);     // 出力: HP：100
    }
}
```

## まとめ

| 用語 | 役割 | 例え（RPG） |
|------|------|-------------|
| フィールド | データを保存する変数 | 「名前」「HP」などのステータス |
| コンストラクタ | `new`された時の初期化処理 | キャラクター作成時の「名前入力・ステータス確定」 |

もしコンストラクタがないと、生まれた瞬間の勇者は「名前なし（`null`）」「HPゼロ」の死んだ状態で始まってしまうかもしれません。**「正しく使える状態で生み出す」**のがコンストラクタの役目です。

---

# varと継承関係の互換性

Java Silverの学習お疲れ様です。「なんとなくエラーになるのはわかるけれど、理屈（特に互換性の話）が腹落ちしない」という点、非常によくあるつまずきポイントです。

結論から言うと、このエラーの原因は**「兄弟（BとC）はお互いに変身できない」という点と、「var は最初の代入で型を固定してしまう」**という2点が組み合わさっていることです。

画像を元に、なぜ「BとCに互換性がない」と言われるのか、わかりやすく解説します。

## 1. 「BとCに互換性がない」とはどういうことか？

まず、クラスの関係図（継承関係）を見てみましょう。

- **A**：親（スーパークラス）
- **B**：Aの子（Aを継承）
- **C**：Aの子（Aを継承）

これを身近な例（動物）に置き換えると一発でイメージできます。

- **A = 「動物」**
- **B = 「イヌ」** （動物の一種）
- **C = 「ネコ」** （動物の一種）

このとき、B（イヌ）とC（ネコ）の関係はどうでしょうか？

どちらも「動物（A）」であることは間違いありません。しかし、**「イヌはネコですか？」と聞かれたら「違います」**よね。

これが解説にある「BクラスとCクラスには互換性がありません」の意味です。

親（A）は共通していますが、兄弟（BとC）同士は全くの別物なので、Bの箱にCを入れる（イヌ専用の小屋にネコを入れる）ことはできません。

## 2. var の正体：型推論の落とし穴

次に、なぜこのコードでその「互換性のなさ」が問題になるのか、`var`の動きを見てみます。

`var` は「右辺を見て、自動的に変数の型を決める（推論する）」機能です。しかし、**一度型が決まったら、それ以降その変数はその型のまま**です（Javaは静的型付け言語であるため）。

コードの流れを追ってみましょう。

### 3行目：`var a = new B();`

コンパイラはこう考えます。

「右辺が `new B()` （イヌ）だな。じゃあ、変数 `a` は **B型（イヌ用）** として作ろう！」

この時点で、プログラム内部では以下のように書き換えられます。

```java
B a = new B(); // 変数aは「Bクラス専用」に固定された！
```

### 4行目：`a = new C();`

ここで問題が起きます。

「変数 `a` はさっき **B型（イヌ用）** にしちゃったぞ。そこに `new C()` （ネコ）を入れようとしてる……。**イヌ用の変数にネコは入らない！ エラーだ！**」

これがコンパイルエラーの正体です。

---

## まとめ：なぜエラーになるのか

解説文にある図解と合わせて、以下の3ステップで理解してください。

1. **型推論の決定：** `var a = new B();` の時点で、変数 `a` は B型（イヌ）に固定された。
2. **兄弟の他人性：** B（イヌ）と C（ネコ）は、同じ親 A（動物）を持っているが、**兄弟同士での交換はできない（互換性がない）**。
3. **代入の失敗：** B型の変数 `a` に、互換性のない C型のインスタンスを入れようとしたため、コンパイルエラー（型の不一致）が発生した。

## もしエラーにならなくするには？（補足）

もし、変数 `a` に B も C も代入したい場合は、共通の親である **A型** として宣言する必要があります。

```java
A a = new B(); // 親である「A（動物）」型の変数なら、B（イヌ）も入るし
a = new C();   // C（ネコ）も入る（これを多態性/ポリモーフィズムと言います）
a.test();      // この場合はCのtest()が呼ばれます
```

`var` を使うと、最も具体的な型（右辺の型そのもの）になってしまうため、このような「兄弟間の入れ替え」ができなくなってしまった、というのがこの問題のポイントでした。

この「兄弟（横の関係）は互換性がない」という感覚はつかめましたでしょうか？

---

# Stringの不変性とメソッドの戻り値について

## 問題のコード

```java
public class Main {
    public static void main(String[] args) {
        String str = "hoge, world.";
        hello(str);
        System.out.println(str);
    }
    
    private static void hello(String msg) {
        msg.replaceAll("hoge", "hello");
    }
}
```

## コードの1行1行の説明

### 1行目: `public class Main {`
- `Main`という名前のパブリッククラスを定義
- `public`はどこからでもアクセス可能
- Javaプログラムは通常クラス内に記述

### 2行目: `public static void main(String[] args) {`
- プログラムのエントリーポイント（`main`メソッド）
- `public`: どこからでも呼び出し可能
- `static`: インスタンスなしで呼び出し可能
- `void`: 戻り値なし
- `String[] args`: コマンドライン引数を受け取る文字列配列

### 3行目: `String str = "hoge, world.";`
- `str`という`String`型の変数を宣言し、`"hoge, world."`で初期化

### 4行目: `hello(str);`
- `hello`メソッドを呼び出し、`str`を引数として渡す

### 5行目: `System.out.println(str);`
- `str`の内容を標準出力に表示（改行付き）
- **注意**: `hello`メソッド内で`replaceAll`を呼び出しても、`String`は不変（immutable）のため`str`は変更されない
- この行では`"hoge, world."`が出力される

### 6行目: `}`
- `main`メソッドの終了

### 7行目: `private static void hello(String msg) {`
- `hello`メソッドの定義
- `private`: このクラス内からのみアクセス可能
- `static`: インスタンスなしで呼び出し可能
- `void`: 戻り値なし
- `String msg`: 文字列型の引数`msg`を受け取る

### 8行目: `msg.replaceAll("hoge", "hello");`
- `msg`内の`"hoge"`をすべて`"hello"`に置換した**新しい文字列**を返す
- **重要な点**: `String`は不変であるため、`replaceAll`メソッドは元の`msg`オブジェクトを変更するのではなく、変更された内容を持つ新しい文字列オブジェクトを生成して返す
- しかし、この行では`replaceAll`が返した新しい文字列をどの変数にも代入していないため、その結果は破棄され、`msg`変数の内容自体は変更されない

### 9行目: `}`
- `hello`メソッドの終了

### 10行目: `}`
- `Main`クラスの終了

## 実行結果

コンソールには`"hoge, world."`と出力されます。これは、`hello`メソッド内の`replaceAll`が元の文字列を変更しないためです。

## voidメソッドの問題点

### 問題点

1. **処理結果を無視している**
   - `msg.replaceAll("hoge", "hello")`は新しい文字列を返しますが、その結果を変数に代入していない
   - そのため、この行は何の効果もありません

2. **メソッドの意図が不明確**
   - メソッド名`hello`からは文字列を変換する印象があるが、実際には何もしていない
   - 呼び出し側からは「変換されたはず」と誤解する可能性がある

### voidメソッドが適切な場合

`void`メソッド自体は問題ありません。以下のような場合に適切です：

```java
// ✅ 副作用を目的としたメソッド（voidが適切）
public void printMessage(String msg) {
    System.out.println(msg);  // 画面に出力する（副作用）
}

public void saveToFile(String data) {
    // ファイルに保存する（副作用）
}

// ✅ オブジェクトの状態を変更するメソッド（voidが適切）
public void setName(String name) {
    this.name = name;  // フィールドを変更する（副作用）
}
```

## 正しい実装方法

### 方法1: 戻り値を返す（推奨）

```java
public class Main {
    public static void main(String[] args) {
        String str = "hoge, world.";
        str = hello(str);  // ← 戻り値を受け取る
        System.out.println(str);
    }
    
    private static String hello(String msg) {  // ← void → String に変更
        return msg.replaceAll("hoge", "hello");  // ← return を追加
    }
}
```

**実行結果:**
```
hello, world.
```

### 方法2: 変換前と変換後の両方を表示する場合

```java
public class Main {
    public static void main(String[] args) {
        String str = "hoge, world.";
        System.out.println(str);  // 1回目: "hoge, world." を表示
        str = hello(str);         // 変換処理
        System.out.println(str);  // 2回目: "hello, world." を表示
    }
    
    private static String hello(String msg) {
        return msg.replaceAll("hoge", "hello");
    }
}
```

**実行結果:**
```
hoge, world.
hello, world.
```

## まとめ

- **`void`メソッド自体は問題ありません**
- **問題は、処理結果を無視している点です**
- **このコードは「何もしないメソッド」になっており、通常は避けるべきです**
- **文字列を変換したい場合は、戻り値を返すメソッドにすべきです**
- **Javaの`String`は不変（immutable）であるため、`replaceAll`などのメソッドは新しい文字列を返すだけで、元の文字列は変更されない**

このコードは、おそらくJavaの`String`の不変性を理解させるための問題か、意図的なバグの例だと思われます。
Javaプログラミングにおいて、**「コンパイルエラー」**と**「実行時の例外」**は、どちらもプログラムが正しく動かない状態を指しますが、発生するタイミングと原因が根本的に異なります。

# コンパイルエラーと実行時に例外がスローされることの違い
一言でいうと、**「実行前に見つかる間違い」**か、**「実行中に起きるトラブル」**かの違いです。

---

## 1. コンパイルエラー (Compile Error)

コンパイルエラーは、ソースコード（`.java`ファイル）をコンピュータが理解できる形式（クラスファイル）に変換する際、**Javaの文法ルールに違反している**ために発生するエラーです。

### 特徴

* **発生タイミング:** プログラムを実行する前（ビルド時）。
* **結果:** プログラム自体が作成されない（実行できない）。
* **修正者:** 開発者がコードを書き直す必要があります。

### 代表的な原因

* セミコロン（`;`）の付け忘れ。
* 変数の型が一致していない（例：`int` 型に文字列を代入しようとする）。
* 定義されていない変数やメソッドを使用している。
* 中括弧 `{ }` の対応が取れていない。

> **たとえるなら：**
> 料理のレシピを書いたとき、文字が汚すぎて読めなかったり、日本語として成立していなかったりして、調理（実行）を始めることすらできない状態です。

---

## 2. 実行時に例外がスローされる (Runtime Exception)

「実行時の例外」は、プログラムの文法自体は正しい（コンパイルは通る）ものの、**実際に動かしてみた結果、予期せぬ事態が起きて処理が継続できなくなった**状態です。

### 特徴

* **発生タイミング:** プログラムの実行中。
* **結果:** プログラムがその時点で異常終了（クラッシュ）する。
* **対応:** `try-catch` 文でエラーを想定して処理を書くか、原因となるバグを取り除く必要があります。

### 代表的な原因

* **NullPointerException:** 中身が空（null）の変数に対して命令を出した。
* **ArithmeticException:** 0で割り算（0除算）をした。
* **ArrayIndexOutOfBoundsException:** 配列の範囲外の番号（インデックス）を指定した。
* **FileNotFoundException:** 指定したファイルが存在しなかった。

> **たとえるなら：**
> レシピの書き方は完璧でしたが、実際に料理を始めたら「卵を割る」という工程で「卵が1つもなかった」ことに気づき、作業がストップしてしまう状態です。

---

## 比較まとめ

| 項目 | コンパイルエラー | 実行時の例外（スロー） |
| --- | --- | --- |
| **見つかる時期** | 実行ボタンを押した直後（または保存時） | 実行中、そのコードに到達した瞬間 |
| **主な原因** | 文法ミス、型の不一致 | 計算ミス、データの欠落、環境の問題 |
| **コードの安全性** | 低い（動かす資格がない） | 比較的高い（文法は正しい） |
| **Javaのスタンス** | 厳格にチェックして実行させない | 実行してみないとわからないので「例外」として扱う |

---

### 次のステップへの提案

今、具体的にどのようなコードでエラーが出ていますか？もし可能であれば、**エラーメッセージやソースコードの一部**を教えていただければ、それがどちらの種類で、どう修正すべきかを一緒に確認できます。

よろしければ、エラーの内容を教えていただけますか？