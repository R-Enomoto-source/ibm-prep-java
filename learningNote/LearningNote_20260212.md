# LearningNote 2026-02-12

## セッションログ（ユーザー入力＋回答）

### Chapter3 復習（java_blackbook 採点結果のポイント解説）

採点結果の「まとめ」に挙がった項目について、復習用に整理したメモです。

---

#### 1. 後置・前置のインクリメント/デクリメントの「式の値」と「評価後の変数の値」（問3）

**ポイント**  
`++` や `--` は「式」として評価され、**式全体の値**と**評価が終わったあとの変数の値**が別です。

- **後置**（`a++` / `a--`）  
  - **式の値**：その時点の `a` の値（増減前）  
  - **評価後**：`a` は 1 増える（または 1 減る）  
  - 「式では古い値を使い、そのあとで変数を更新する」と覚える。
- **前置**（`++a` / `--a`）  
  - **式の値**：更新後の `a` の値（1 増えた/減ったあと）  
  - **評価後**：すでに 1 増減している  
  - 「先に変数を更新し、その新しい値を式の値として使う」と覚える。

**例**  
`int a = 10;` のとき  
- `a++` → 式の値は **10**、評価後は `a = 11`  
- `++a` → 先に `a` が 11 になり、式の値は **11**

計算式の中で複数回 `a++` や `a--` が出てくる場合は、「その式で使う値」と「その直後の `a` の値」を区別して追うと間違えにくいです。

---

#### 2. 複数変数宣言の文法（問6）

**ポイント**  
**同じ型**の変数を、1つの宣言文でカンマ区切りで複数宣言できます。

- **OK**  
  `int a = 100, b = 20, c = 30;`  
  → すべて `int` なので、`a`, `b`, `c` を一度に宣言できる。
- **NG**  
  `int a = 1, long b = 2;`  
  → 型が違うので、1つの宣言文に混在させられない。別々に `int a = 1;` と `long b = 2;` と書く必要がある。

「複数変数宣言は、同じ型に限る」と押さえておくとよいです。

---

#### 3. オーバーライドとオーバーロードの違いと、変数の宣言型で決まるメソッド呼び出し（問10）

**ポイント**

- **オーバーライド**  
  親クラスで定義されたメソッドを、子クラスで**同じシグネチャ**（メソッド名・引数の型・数・順序）で再定義すること。  
  実行時に**実際のオブジェクトの型**に応じて、子クラス側のメソッドが呼ばれる。
- **オーバーロード**  
  同じクラス内で、**同じメソッド名**で**引数が異なる**複数のメソッドを定義すること。  
  どれが呼ばれるかは**コンパイル時に、引数の型・数・順序**で決まる。

**問10で大事な点**  
変数が `Object` 型で宣言されていると、コンパイル時には「Object のメソッド」しか見えない。  
子クラスに `equals(Sample obj)` のように**引数が Sample のメソッド**があると、それは **Object の `equals(Object)` のオーバーライドにはならない**（引数型が違うのでオーバーロードになる）。  
そのため、`Object` 型の変数から `equals` を呼ぶと、**Object の equals（参照比較）** が呼ばれ、別インスタンスなら `false` になる。

- **呼ばれるメソッド**は、**変数の宣言型**（ここでは `Object`）で決まる。  
- **オーバーライド**になるには、親と同じ「`equals(Object obj)`」で子クラスに定義する必要がある。

---

#### 4. レシーバが null でない限り、引数が null でも equals は呼べる（問11）

**ポイント**  
`a.equals(b)` では、

- **レシーバ**＝メソッドを呼ぶ側 → `a`  
- **引数**＝メソッドに渡す値 → `b`

`a` が `null` でないなら、`a.equals(...)` という**呼び出し自体は有効**です。  
`b` が `null` でもコンパイルエラーにはならず、`equals` が実行される。

`Object` の `equals(Object obj)` の仕様では、**引数が null のときは false を返す**と決まっているので、  
`a` が有効なオブジェクトで `b` が `null` なら、`a.equals(b)` は `false` を返します。

**注意**  
`a` が `null` のときに `a.equals(b)` を呼ぶと NullPointerException になる。  
「どちらが null かもしれないか」を区別して考えるとよいです。

---

#### 5. if に {} がなくても直後の1文だけが if に属する（問14）

**ポイント**  
`if (条件)` の直後に **ブロック `{ }` を書かない**場合、**直後の1文だけ**がその if に属します。

```text
if (false)
    System.out.println("A");   // この1文だけが if に属する（実行されない）
System.out.println("B");       // if の外 → 常に実行される
```

このとき「A」は表示されず、「B」だけが表示されます。  
2行目は if の外なので、条件の真偽に関係なく実行されます。

読み間違いを防ぐため、**実務では if の本体は `{ }` で囲む**書き方が推奨されます。

---

#### 6. switch で使える型（long 不可、enum 可）（問17）

**ポイント**  
Java の `switch` の括弧の中（および `case` の値）に使える型は決まっています。

- **使える型**  
  `char`, `byte`, `short`, `int`, **String**（Java 7 以降）, **enum**
- **使えない型**  
  **long**, **boolean**, float, double など

`long` は範囲が広く、case を網羅しづらいなどの理由から、switch では使えません。  
`enum` は列挙型なので、取り得る値が限定されており、switch で使えます。

---

#### 7. case には定数式が必要で、変数は使えない（問18）

**ポイント**  
`case` の後ろに書けるのは **コンパイル時に値が決まる定数式** です。

- **OK**  
  - リテラル：`case 1:`, `case "A":`  
  - 定数式：`case 2*5:`（コンパイル時に 10 と決まる）  
  - `enum` の定数
- **NG**  
  - 変数：`case num:`（実行時でないと値が決まらない）

「case には変数は書けない」「定数や定数式だけ」と覚えるとよいです。

---

#### 8. switch式では全 case のカバーまたは default が必要（問22）

**ポイント**  
**switch 式**（値を返す `switch`）では、「どの分岐をたどっても必ず何かしら値が決まる」ことがコンパイル時に要求されます。

- 取り得る値のすべてが `case` で網羅されているか、  
- そうでなければ **default** で残りをすべて受け止めるか、  
のどちらかが必要です。

例えば `int` の式を switch しているのに、0～5 に対応する case がなく、default もないと、  
「ある値に対して返す値が決まらない」とみなされ、**コンパイルエラー**になります。

---

#### 9. switch式の構文（セミコロンや return の要否）（問23）

**ポイント**  
**switch 式**では、

- 全体を `switch (...) { ... }` の形で書き、式として使うので、文の終わりでは `};` のようにセミコロンで閉じる。
- **アロー構文** `case x -> 式;` の場合は、その case の「結果」がその式の値になり、**return は不要**（return はメソッドを抜けるため、ここでは使わない）。
- ブロック `case x -> { ... }` を書く場合は、値を返すために **yield 値;** を使う。

「switch 式では値を返すだけなので、アローで式を書く場合は return は要らない」「ブロック内で結果を返すときは yield」と整理するとよいです。

---

#### 10. for の初期化で異なる型をカンマで宣言できない（問28）

**ポイント**  
`for` の初期化部で、カンマで複数の変数を宣言する場合、**すべて同じ型**である必要があります。

- **OK**  
  `for (int i = 1, j = 2; ...)`  
  → どちらも `int`
- **NG**  
  `for (int i = 1, long j = 2; ...)`  
  → `int` と `long` が混在しているのでコンパイルエラー。

異なる型の変数を使いたい場合は、初期化部では同じ型だけにするか、片方（または両方）を for の外で宣言する必要があります。

---

#### 11. for の条件部でカンマで複数条件を書けない（問31）

**ポイント**  
`for` の**条件部**（2番目の `;` で区切られた部分）には、**boolean になる式を1つ**だけ書きます。

- Java には C 言語のような「カンマ演算子」が **for の条件部では使えない** ため、  
  `for (...; i < 3, j < 5; ...)` のようにカンマで複数の条件を並べることはできません。
- 複数の条件を使いたい場合は、  
  `for (...; i < 3 && j < 5; ...)` のように **論理演算子（&& や ||）** で1つの boolean 式にまとめます。

---

#### 12. 拡張 for の変数への代入は配列要素を変更しない（問37）

**ポイント**  
拡張 for 文は次の形です。

```text
for (要素の型 変数 : 配列やコレクション)
```

ここで出てくる **変数** は、ループ用の**ローカル変数**です。  
各反復で、その変数に「配列の要素の値（参照の場合は参照値）」が**コピー**されて入ります。

- この変数に別の値を**代入**しても、それは「ローカル変数が指す先を変えた」だけで、  
  **元の配列の要素**は変わりません。
- 配列の要素そのものを変えたい場合は、**インデックスを使った通常の for** で `array[i] = 新しい値` のように代入する必要があります。

---

#### 13. do-while と等価な while の前置/後置の対応（問38）

**ポイント**  
`do { ... } while (条件);` を、条件判定のタイミングが同じになるように `while` に書き換える場合、**インクリメント/デクリメントの前置・後置**をそろえる必要があります。

- do-while では、**まずブロックを実行**し、そのあとで **条件** を評価します。
- ブロック内で `num++`（後置）を使っているなら、「ブロック実行後の num の値」が条件式に影響する。
- これを while で再現するには、条件式で使う `num` の更新を **前置（++num）** にするか **後置（num++）** にするかを、  
  「ブロックを実行したあと、条件を評価するときの num の値」と一致させる必要があります。

「do-while の 1 回目の実行 → 条件評価」の流れと、「while の 1 回目の実行 → 条件評価」の流れで、  
**同じタイミングで同じ値**になるように前置/後置を選ぶ、と考えるとよいです。

---

#### 14. ラベルが付けられる対象（try ブロックなど）（問42）

**ポイント**  
Java で**ラベル**を付けられるのは、主に次のような「文」です。

- **ループ文**（for, while, do-while）
- **ブロック** `{ ... }`
- **try ブロック**（try の直後の `{ ... }` に対応する文）

`break` や `continue` でラベルを指定すると、そのラベルの付いた文の直後へ制御を移せます。  
**if 文や switch 文**には、ラベルを付けて break/continue の飛び先にすることは（言語仕様上）想定されていません。  
このため、「ラベルが付けられる対象」として正しいのは、例えば **try ブロック** です。

---

#### 15. ラベル付き continue で外側ループの「次」に飛んだあとも、別の i で内側が再度実行される（問43）

**ポイント**  
二重ループで、外側にラベル `a` を付けた場合、`continue a;` は「**外側のループの、次の反復**」に進みます。

- つまり、**今の外側の反復は打ち切り**、外側のループ変数（例：`i`）が次の値に進み、**内側のループが最初からもう一度**実行されます。
- したがって、`i = 1` のときと `i = 3` のときのように、**異なる `i` の値**で、それぞれ内側ループが**別々に**実行されます。
- 内側で `total += j` のように加算していると、**i=1 のときの加算**と**i=3 のときの加算**の両方が行われ、  
  問43のように「6 + 6 = 12」のように合計されることになります。

「continue ラベル」は「そのラベルの付いたループの、次の反復へ」と理解し、  
外側の次の `i` で内側が再度最初から回ることを押さえておくとよいです。

---

