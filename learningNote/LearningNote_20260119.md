# LearningNote 2026-01-19

## セッションログ（ユーザー入力＋回答）

### Cleric.java の仕様チェック（exerciseExplain との照合）

ユーザー: C:\Users\20171\IT_Learning\pre-joining-learning\sukkiri_java_exercises\Chpter8\Cleric.java
は
Chapter8\exerciseExplain
の仕様通りに作成できていますか？

アシスタント: 両方の内容を確認しました。`Cleric.java` を `exerciseExplain` の仕様と照らし合わせた結果です。

#### 仕様との照合結果

**練習8-1 ✓**
- `Cleric` クラスが `public` で宣言されている → **問題なし**

**練習8-2 ✓**
- 名前（`name`）、HP、最大HP（`MAX_HP`）、MP、最大MP（`MAX_MP`）がある
- HP・最大HP の初期値 50、MP・最大MP の初期値 10
- 最大HP・最大MP が `final` の定数 → **問題なし**

**練習8-3 ✓**
- `selfAid()` が引数なし・戻り値なし
- MP を 5 消費し、HP を最大HPまで回復 → **問題なし**

**練習8-4 △（不備あり）**

`pray()` には次の点で仕様とずれがあります。

1. **「0〜2ポイントの補正」の扱い**
   - 仕様: 祈った秒数 + **ランダムで 0〜2**  
     （例: 3秒 → 3〜5のいずれか）
   - 現状: `second + random.nextInt(3)`  
     - `nextInt(3)` は 0, 1, 2 なので、**補正の計算は正しい** ✓

2. **「実際に回復したMPの量」が正しくない**
   - 仕様: **実際に回復したMPの量** を返す  
     （最大MPを超えないようにした後の増分）
   - 現状: `recoverMp` をそのまま返しており、**`this.mp` を増やしていない**  
     → 戻り値が「実際の回復量」になっていない

3. **「最大MPを超えて回復しない」の未実装**
   - 仕様: 最大MPを超えて回復しない  
   - 現状: そのチェックがない  
     - 例: `mp=9`, `MAX_MP=10`, `recoverMp=5` のとき、実際の回復は 1 であるべき

4. **その他の不具合**
   - 4行目に不要な `;` のみの行がある
   - `import java.util.Random;` と `new java.util.Random()` の二重指定（どちらかでよい）

---

#### 修正案

`pray()` を仕様どおりにした例です。

- 回復量 = `second + random.nextInt(3)`（0〜2の補正）
- 実際の回復 = `Math.min(recoverMp, MAX_MP - mp)` で最大MPを超えないようにする
- `this.mp` にその値を足す
- 戻り値は **実際に回復した量** にする

あわせて、4行目の余分な `;` の行を削除し、`Random` の import / 使用をどちらか一方にそろえるとよいです。

---

### 間違っているところだけの一覧

ユーザー: 間違っているところだけ教えて下さい

アシスタント: 間違っているところだけです。

---

#### 1. 4行目：余分な行

```java
;
```

この `;` だけの行は不要なので削除してください。

---

#### 2. `pray()`：MPを増やしていない

`recoverMp` を計算しているだけで、`this.mp` に足していません。  
祈った分だけ `this.mp` を増やす処理が必要です。

---

#### 3. `pray()`：「最大MPを超えて回復しない」の処理がない

仕様では「最大MPを超えて回復することはありません」とあるので、  
`recoverMp` をそのまま足すのではなく、

- 実際に回復できる量 = `Math.min(recoverMp, MAX_MP - this.mp)`
- その分だけ `this.mp` を増やす

といった形で、`MAX_MP` を超えないようにする必要があります。

---

#### 4. `pray()`：戻り値が「実際に回復したMP」になっていない

仕様では「実際に回復したMPの量」を返すとあるので、

- 上で計算した「実際に回復した量」を `this.mp` に足したあと、
- その「実際に回復した量」を `return` する

ようにしてください。今は `recoverMp`（理論上の回復量）を返しているだけになっています。

---

以上が、`Cleric.java` で直すべき点です。

---

### `pray()` の「最大MPを超えない」処理の追加

ユーザー: 3以外は直せたと思います

アシスタント: 1、2、4は直っています。3の「最大MPを超えて回復しない」処理を追加しました。

**変更点：**

- **`Math.min(recoverMp, this.MAX_MP - this.mp)`**  
  回復量 `recoverMp` と、残り容量 `MAX_MP - mp` の小さいほうを「実際の回復量」にしています。  
  例：`mp=8`, `MAX_MP=10`, `recoverMp=5` のとき → 実際の回復は `2` だけになります。

- **`this.mp += actualRecover`**  
  上で求めた「実際の回復量」だけ `mp` を増やしています。

- **`return actualRecover`**  
  仕様の「実際に回復したMPの量」を返すように、`return this.mp` から `return actualRecover` に変更しました。

この内容で、`pray()` は仕様どおり動くはずです。

---

### `Math.min` を用いた recoverActual のコード解説

ユーザー: 下記のコードの意味を解説してください
int recoverActual = Math.min(this.MAX_MP - this.mp, recoverMp);

アシスタント: この1行の意味を分解します。

---

#### 1. `Math.min( A, B )`

`Math.min` は、**2つの引数のうち小さい方**を返します。

- `Math.min(3, 5)` → `3`
- `Math.min(8, 2)` → `2`

---

#### 2. 第1引数：`this.MAX_MP - this.mp`

**「あとどれだけ MP を増やせるか」** = **残り容量**を表しています。

| MAX_MP | mp（現在） | MAX_MP - mp（残り容量） |
|--------|------------|--------------------------|
| 10     | 7          | 3                        |
| 10     | 2          | 8                        |
| 10     | 10         | 0                        |

---

#### 3. 第2引数：`recoverMp`

祈りで**理論上回復する MP**（`second + ランダム0〜2`）です。

---

#### 4. 全体の意味

「**残り容量**」と「**理論上の回復量**」の**小さい方**を `recoverActual` にしています。

- 残り容量の方が小さい → それ以上は増やせないので、**残り容量まで**しか回復しない  
- 理論上の回復量の方が小さい → 最大MPに届かないので、**理論上の回復量どおり**回復する  

つまり、「**最大MPを超えない範囲で、実際に回復するMP**」を計算しています。

---

#### 5. 具体例

| mp | MAX_MP | recoverMp | 残り (MAX_MP - mp) | min(残り, recoverMp) = recoverActual |
|----|--------|-----------|---------------------|--------------------------------------|
| 7  | 10     | 5         | 3                   | **3**（5回復すると11になり超えるので3だけ） |
| 2  | 10     | 5         | 8                   | **5**（5回復しても7で、まだ余裕がある）     |
| 10 | 10     | 5         | 0                   | **0**（すでに最大なので回復しない）         |

---

#### 補足：`return` について

いま `return this.mp;` になっていますが、仕様では **「実際に回復した MP の量」** を返すことになっているので、`return recoverActual;` の方が仕様に合います。`this.mp` は回復**後**の MP 合計です。

---

### Math.min やコードの思いつき方（パターンと調べ方）

ユーザー: どうすれば思いつけますか？
そもそもMath.min(A,B)を知りませんでした

アシスタント: 「どうすれば思いつけるか」は、**考え方のパターン**と**ツールの探し方**の2つに分けて整理するとわかりやすいです。

---

#### 1. 考え方のパターン：「上限で切り詰める」

仕様の「**最大MPを超えて回復しない**」をそのまま言い換えると、

> **「回復後のMP」は、必ず MAX_MP 以下にしたい**

になります。

ここで、

- **理論上の回復後** = `this.mp + recoverMp`
- **許される最大** = `this.MAX_MP`

なので、

- 許される最大を超えそう → **超える分は捨てる（切り詰める）**
- 超えなさそう → **そのまま使う**

と考えると、

> **「使ってよい回復量」＝ `recoverMp` と「あとどれだけ増やしてよいか」の**小さい方**

という発想になります。

- 「あとどれだけ増やしてよいか」= `this.MAX_MP - this.mp`
- 「小さい方を取る」= **min(残り, recoverMp)**

なので、

```
実際の回復量 = min(残り容量, 理論上の回復量)
```

という形になり、`Math.min(this.MAX_MP - this.mp, recoverMp)` に自然につながります。

**覚えておくと便利なパターン：**

> **「〇〇を△△を超えないようにしたい」**  
> → **「結果 = min(欲しい値, 上限)」** や **「結果 = min(残り, 加算する量)」** を疑う

---

#### 2. `Math.min` のようなメソッドの探し方

「小さい方を取りたい」と思えたあと、Java でどう書くかは**調べる**で十分です。

##### ① 「Java 小さい方 二つの値」で検索

- 「Java 2つの値 小さい方」「Java min 2つの数」などで検索すると、`Math.min` がすぐ出ます。

##### ② `Math` クラスをざっと眺める

- `Math` はよく使うので、`Math.` と打って IDE の補完で一覧を出したり、
- 公式の [Math (Java Platform SE)](https://docs.oracle.com/javase/jp/8/docs/api/java/lang/Math.html) を見ると、
  - `min`, `max`, `abs` など、似たような「2つの値から1つ選ぶ／変換する」メソッドが並んでいます。

##### ③ 似た処理を学んだらセットで覚える

| やりたいこと           | メソッド       | 例                          |
|------------------------|----------------|-----------------------------|
| 小さい方               | `Math.min(a,b)`| `Math.min(3, 5)` → 3        |
| 大きい方               | `Math.max(a,b)`| `Math.max(3, 5)` → 5        |
| 絶対値                 | `Math.abs(a)`  | `Math.abs(-3)` → 3          |

「上限で切り詰める」は **min**、「下限で底上げする」は **max** とセットで覚えておくと応用しやすいです。

---

#### 3. 思いつけなくても大丈夫、という前提

- `Math.min` を知らなくても、「2つのうち小さい方」という**発想**があれば、  
  - 検索で「Java 小さい方」  
  - または `if (recoverMp > 残り) { recoverMp = 残り; }` のような `if` で書く、  
  のどちらかには必ずたどり着けます。
- 大切なのは、
  1. **「最大を超えない＝小さい方を取る」というパターン**を理解すること  
  2. **「どう書くか」は検索・リファレンスで補う**こと  

「思いつく」というより、  
**「パターンは勉強で身につけ、具体的なメソッド名は調べて使う」** が現実的で、その繰り返しで自然に思いつけるようになります。

---

#### 4. 復習用：同じパターンの例

- **HPの回復で「最大HPを超えない」**  
  - `actualRecover = Math.min(recoverHp, MAX_HP - this.hp);`
- **ダメージで「0未満にしない」**  
  - `this.hp = Math.max(0, this.hp - damage);`（0か「hp - damage」の大きい方＝つまり 0 を下回らない）

「〇〇を△△の範囲に収めたい」という制約があるときは、`Math.min` / `Math.max` を思い浮かべてみる、というクセをつけておくと、次からは思いつきやすくなります。

---

### 処理の文章化→文法・APIの調査という学び

ユーザー: どうすれば良いかは何となく思いついていました。
ただ、それをJavaで正しくコーディングする書き方を知りませんでした。
ただ、明確に言語化できていないかったので、処理をコードでの書き方が分からなくても文章でどう処理したいかを書いて、それを基にメソッドなど、Javaの文法を調べればよいと思いました。

アシスタント: その整理の仕方で合っています。

---

#### 文章に落とす → そこから文法やAPIを探す

**「何をしたいか」を文章で書く**  
↓  
**その文章に合わせて、文法やメソッドを調べる**

という流れは、実務でもよく使うやり方です。

---

#### 今回の例で言うと

**文章で書くと：**

> 「理論上の回復量 `recoverMp` と、あと増やしてよい量 `MAX_MP - mp` の**小さい方**を、実際の回復量にする」

ここまで書ければ、検索は例えば：

- 「Java 2つの値 小さい方」
- 「Java 小さい方 選ぶ」
- 「Java 二つの数 小さい」

のようなワードで十分で、`Math.min` にたどり着けます。

---

#### 文章化のコツ

- **「〜の小さい方」「〜の大きい方」** → `Math.min` / `Math.max` を疑う  
- **「〜を超えない」「〜以下に抑える」** → 「小さい方」に言い換えられないか考える  
- **「〜を下回らない」「0より小さくしない」** → 「大きい方」に言い換えられないか考える  

「どう処理したいか」を**日本語で短くはっきり書く**練習をすると、  
「この文章に対応するメソッド・書き方は何か」を調べやすくなります。

---

#### まとめ

- **思いついたこと** → まず文章で「こうしたい」と書く  
- **書き方** → その文章をキーワードに、文法や `Math.min` のようなAPIを調べる  

このやり方を続けていくと、  
「文章 → キーワード → 調べる」が自然にできるようになります。

---

### AI に聞くことと検索の使い分け

ユーザー: 検索ではなくAIにこうしたいがどういう書き方があるかを聞くのが早そうですね

アシスタント: その感覚でだいたい合っています。

---

#### AI に聞くメリット

- **「こうしたい」を日本語で言えばよい**ので、キーワードを考えなくて済む
- **文脈（Java、Cleric、pray など）** を一緒に渡せる
- **「小さい方を取りたい」→ `Math.min`** のように、考え方から書き方まで一気に教えてもらえる
- 検索して複数ページを見るより、**答がまとまって返ってくることが多い**

---

#### 検索が向いている場面

- **最新の仕様・バージョン**（「Java 21 の〇〇」「〇〇 2.0 の変更点」など）
- **公式の細かい仕様**（リファレンスの正確な説明）
- **AI の回答を自分で確認したいとき**（公式ドキュメントで裏を取りたい）

---

#### おすすめの使い分け

| やりたいこと | 向いている方 |
|--------------|--------------|
| 「こういう処理を Java でどう書くか」 | **AI に聞く** |
| 「このエラーは何か」「この書き方の意味」 | **AI に聞く** |
| 公式の正確な仕様・仕様変更の確認 | **検索・リファレンス** |

---

「こうしたい」を日本語で言って、書き方を AI に聞くやり方は、学習中はとても有効です。  
そのうえで、重要なところは公式ドキュメントや検索で一度確認する habit があると、より安心だと思います。

---

### 公式ドキュメントでの確認のメリットとやり方

ユーザー: そのうえで、重要なところは公式ドキュメントや検索で一度確認する habit があると、より安心だと思います。
これをするメリットとやり方を教えてください

アシスタント: 以下、**メリット**と**やり方**を分けてまとめます。

---

#### 確認するメリット

##### 1. **AI の誤りを防げる**
- AI は古い情報や、存在しない API・構文を答えることがある
- 公式や一次情報で照らすと、「本当にそうなのか」を自分で確かめられる

##### 2. **理解が深まる**
- ドキュメントには「例」「引数」「戻り値」「例外」などがまとまっている
- 見ることで、**似たメソッド**や**よくある使い方**を一度に把握できる

##### 3. **自分で調べる力がつく**
- 検索 → 公式 → 読む、を繰り返すと、「何をどこで調べるか」の勘が養われる
- チュートリアルが終わったあとも、自分で学び続けやすくなる

##### 4. **実務でそのまま使える**
- 仕事では「AI の言うことをそのまま使う」より、「仕様・公式と照らして判断する」ことが重要
- 今のうちから「一度確認する」習慣をつけておくと、後が楽になる

---

#### やり方（習慣にしやすい流れ）

##### ステップ1：**「ここは確認しておきたい」を決める**

次のようなところは、確認の優先度を高くする目安です。

| 優先度高め | 例 |
|------------|-----|
| 初めて使うクラス・メソッド | `Math.min` を初めて使う |
| 本番・提出に関わる処理 | 決済、認証、データ保存など |
| エラーの原因がよくわからない | 例外メッセージ、スタックトレース |
| 仕様・公式の言い方とずれそう | 「推奨」「非推奨」「将来削除」などの注記 |

逆に、`println` のように何度も使っているものは、毎回確認する必要はありません。

---

##### ステップ2：**公式ドキュメントを開く**

**Java 標準 API（日本語）**

- トップ:  
  https://docs.oracle.com/javase/jp/8/docs/api/
- クラス名がわかっているときは  
  `https://docs.oracle.com/javase/jp/8/docs/api/java/lang/Math.html`  
  のように「パッケージ＋クラス名」で直接開ける

**よく使うクラスの場所（`java.lang` は import 不要）**

- `Math` → `java.lang.Math`
- `String` → `java.lang.String`
- `Integer` → `java.lang.Integer`
- `Random` → `java.util.Random`
- `ArrayList` → `java.util.ArrayList`

---

##### ステップ3：**ドキュメントで見るポイント**

1. **メソッドの説明**
   - 何をするメソッドか、仕様が書いてあるか
2. **引数（Parameters）**
   - 型、意味、`null` 可か
3. **戻り値（Returns）**
   - 型と、どんな値を返すか
4. **例外（Throws）**
   - どんなときに例外が出るか（あれば）
5. **Since / バージョン**
   - 自分の Java バージョンで使えるか

`Math.min` の例だと：

- `min(int a, int b)` の説明
- `int` を 2 つ受け取り、小さい方の `int` を返す
- オーバーロードで `long` などもある、といったところを見るイメージです。

---

##### ステップ4：**検索を使う場面**

- **クラス名やメソッド名がわからない**
  - 例：「Java 2つの数 小さい方」→ 出てきた `Math.min` を公式で確認
- **公式の日本語がわかりにくい**
  - 例：「Math min 公式」や「Oracle Java Math.min」
- **「推奨」「非推奨」「代替」を知りたい**
  - 例：「Java Random nextInt 非推奨」「Optional 推奨」など

検索で見つけたら、**リンクのドメイン**で `docs.oracle.com` を優先すると、公式に近い情報を選びやすいです。

---

#### 実際のサイクル例（`Math.min` の場合）

1. AI に「2つの値の小さい方を取りたい」と聞く → `Math.min` を教えてもらう  
2. 「公式で一度確認しておこう」と決める  
3. `Math` で検索するか、`java/lang/Math.html` を開く  
4. `min` の  
   - 説明  
   - シグネチャ（`min(int a, int b)` など）  
   - 戻り値  
  をサッと読む  
5. 「int の min はこういう意味で、こう使えばいい」と自分で納得する  

ここまで 1〜2 分でできると、習慣にしやすいです。

---

#### まとめ

- **メリット**: AI のミスを減らせる、理解が深まる、自分で調べる力がつく、実務でも使える  
- **やり方**:  
  1. 初使用・重要そうなところだけ「確認する」と決める  
  2. クラス名がわかれば `docs.oracle.com` の該当クラスを開く  
  3. メソッドの説明・引数・戻り値・例外を短く眺める  
  4. 名前がわからないときは検索 → 公式のページを開いて同じように確認  

最初は「1日1つ、使ったメソッドの公式を 1 回開く」くらいの軽さで始めると、習慣にしやすいです。

### super なしの attack() が無限ループになる理由（this と「最も外側」）

ユーザー: これが無限ループになってしまうのは、もっとも外側のインスタンスがそれ自体だから、外側を指定→外側に行く→外側を見る→外側を指定、でループが発生するからですか？

アシスタント: はい、その理解で大きく外れていません。より正確にいうと、**「外側を指定→外側に行く→…」というより、「自分（今動いているメソッド）を指定→自分が呼ばれる→その中でまた自分を指定→…」という再帰**になっている、というイメージの方が少し近いです。

#### 何が起きているか

`super` を付けずに `attack()` と書くと、それは **`this.attack()` と同じ** になります。

- **`this`**  
  「このインスタンス」を指す言葉で、継承の文脈では「**そのオブジェクトの実際の型（一番派生したクラス＝いちばん外側のクラス）**」の視点でメソッドを探す、という意味合いになります。教科書の「インスタンスの最も外側の部分」は、この「一番外側のクラス（サブクラス側）」を指していると考えてよいです。

- **`this.attack()` の解決の仕方**  
  Java では、`this.attack()` は「**実行時の型**」に従って、**オーバーライド済みの一番外側（サブクラス側）の `attack()`** を選びます。いま `attack()` をオーバーライドしているサブクラスの中にいるなら、それは **自分自身の `attack()`** です。

だから、

1. サブクラスの `attack()` の実行中に  
2. `attack()` または `this.attack()` を呼ぶ  
   → 解決されるのは **同じサブクラスの `attack()`**（＝今実行中のメソッド）  
3. その `attack()` の先頭からまた実行され、その中でまた `attack()` / `this.attack()` が呼ばれる  
4. 以降、同じメソッドを延々と呼び続ける  

という **自分自身のメソッドの再帰呼び出し** になり、終了条件がないため **無限ループ（正確にはスタックオーバーフローになる無限再帰）** になります。

#### 「外側」のイメージについて

「もっとも外側のインスタンスがそれ自体」という感覚は、こう言い換えられます。

- 継承の「入れ子」でいう「一番外側」＝サブクラス（今 `attack()` をオーバーライドしているクラス）
- `this` でメソッドを呼ぶと、その「一番外側」のクラスにある `attack()` が選ばれる
- いま私たちがいるのは、まさにその「一番外側」の `attack()` の中

なので、

- 「外側を指定する」＝`this.attack()` で「このオブジェクトの（一番外側の）`attack()` を呼ぶ」
- 「外側に行く」＝その `attack()` が実行される＝実質「自分自身の `attack()` の先頭に戻る」
- 「外側を見る」＝そこでまた `attack()` / `this.attack()` が書かれている
- 「外側を指定」＝また自分自身の `attack()` を呼ぶ

という **「外側＝自分自身」の往復** が繰り返され、ループになる、という理解で問題ありません。**「外側＝自分自身」だから、同じメソッドを呼び続ける**、という点が重要です。

#### super.attack() なら大丈夫な理由

`super.attack()` のときは、

- 「**このオブジェクトの、スーパークラス側の `attack()`**」を明示的に指定している  
- つまり、「いまの（外側の）`attack()` ではなく、**親の `attack()`**」を呼ぶ  

ので、自分自身の `attack()` を再び呼ぶことはなく、再帰にはなりません。ここが「`super` を付けないとダメ」な理由です。

### 「使っちゃダメなメンバ」があるクラスが「怖くて使えない」理由

ユーザー: 怖くて使えないのは、コーディングするときに親クラスのソースコードの中身が分からず、知らず知らずのうちに間違いを犯してしまう可能性があるから、と考えてよいですか？

アシスタント: はい、その理解でよいです。かなり核心を押さえています。

#### ご理解の通り、「知らずに間違える」が主な理由です

**「親クラスのソースや意図が分からず、知らないうちに"使っちゃダメ"なものを使ってしまう」** というのは、「怖くて使えない」という感覚の中心にある理由です。

#### 具体的に何が怖いか

##### 1. ソースが見えない・分からない状況

- ライブラリやフレームワークのクラスなら、**ソースを持っていない**ことが多い
- 自分たちの親クラスでも、**作った人と使う人が違う**と、「`getDamage()` は内部用で、外から呼ばない想定」といった**暗黙のルール**が伝わらない
- 一覧には `getDamage()` が並んでいるので、**「使っていいメソッド」に見えてしまう**

##### 2. 知らずに使ってしまう流れ

- IDE の補完に `getDamage()` が出る  
  → 「名前から使えそう」と思って使う  
  → 実際は壊れた値や副作用、将来の仕様変更のリスクがある  
- いまは動いているように見えても、**別のバージョンや別の条件下で落ちる**など、原因の分かりにくいバグになりやすい

##### 3. 「使うな」をルールで守るのが難しい

- 「`getDamage()` は使わないこと」をコメントやドキュメントに書いても、**読まない・忘れる・新人が知らない** といったことが起きる
- クラスに「使っちゃダメ」がたくさんあると、**「どれが安全でどれが危険か」を毎回思い出さないといけない** ので、心理的にも負担が大きい

#### 設計としての教訓

だからこそ、

- **使ってもよいものだけを `public` にする**
- **内部用は `private` や `protected` で隠し、外から呼べないようにする**
- **「存在するが使うな」というメンバを減らし、「見えている＝使ってよい」に近づける**

といった設計が推奨されます。

まとめると、**「中身や意図が分からないまま、うっかり"使っちゃダメ"なものを使ってしまう可能性があるから怖い」** という理解で問題ありません。

### 「使っちゃダメなメンバ」の実務での具体例（初学者向け）

ユーザー: 初学者にもわかりやすいように実務での具体例を交えて説明してください

アシスタント: 「存在するが使っちゃダメなメンバ」がなぜ怖いかを、**実務に近い具体例**で説明します。

---

#### 例1：注文の「合計金額」を取るクラス（ECサイト）

##### 状況

```
Order（注文）クラス
├── getTotalPrice()      ← 税込・割引後。画面に表示するならこれ
├── getSubtotal()        ← 税抜小計。内部計算用、表示には使わない想定
└── getRawAmount()       ← 仕様変更前の互換用。新規では使うな
```

- **使う側（あなた）**：注文一覧画面で「合計金額」を出したい。
- **知らないこと**：親クラスや共通ライブラリのソースを見ていない。「どのメソッドが"表示用"で、どれが"内部用"か」が分からない。

##### 何が起きるか

- IDE の補完に `getSubtotal()` や `getRawAmount()` も出る  
  → 「合計っぽい」と思って `getSubtotal()` を使ってしまう  
- 結果：税が含まれていない金額を表示してしまう、古い計算ロジックの `getRawAmount()` を使い、割引が二重になる

**「中身を知らないまま、存在するメソッドを安易に使ってバグを出す」** 典型です。

---

#### 例2：決済処理のクラス（支払いシステム）

##### 状況

```
PaymentService（決済サービス）クラス
├── charge(金額, 顧客ID)     ← 通常はこれ。ログ・エラー処理・多重課金チェックあり
└── _directCharge(金額)     ← テスト・レガシー用。チェックなし、本来は外から呼ぶな
```

- **使う側**：新機能で「カートの内容で課金する」処理を書きたい。
- **知らないこと**：`_directCharge` が「チェックやログをすっとばす」危険なメソッドだということ。命名の `_` の意味を理解していない、または見落とす。

##### 何が起きるか

- 補完や検索で `_directCharge` を見つけ、「こっちの方がシンプル」と使ってしまう  
- 結果：多重課金のチェックが動かず、同じ注文で二重請求される。監査用のログが残らず、問題の追跡ができない。

**「ソースや設計意図が分からないまま、"楽そうな"危険なメソッドを選んでしまう」** 例です。

---

#### 例3：ユーザー認証のクラス（ログイン機能）

##### 状況

```
User（ユーザー）クラス
├── getName()           ← 表示用。これを使う
├── getEmail()          ← 表示・メール送信用。使ってよい
└── getPasswordHash()   ← 認証ロジックの内部用。アプリ側からは絶対触るな
```

- **使う側**：管理画面に「ユーザー一覧（名前・メール）」を出したい。
- **知らないこと**：`getPasswordHash()` が「パスワードのハッシュ」で、絶対に画面や外部に渡してはいけないこと。

##### 何が起きるか

- 一覧用に「ユーザーの持ってる情報を全部出そう」と、`getName()`, `getEmail()` に加えて `getPasswordHash()` も API や JSON に含めてしまう  
- 結果：ハッシュが漏れると、別のシステムで破解されたときにアカウント乗っ取りのリスクがある。

**「"使っちゃダメ"が明示されておらず、意図せず深刻なセキュリティ問題を起こす」** 例です。

---

#### 例4：日付を扱うクラス（レポート・帳票）

##### 状況

```
ReportDate（レポート用の日付）クラス
├── toDisplayString()     ← "2025年1月15日" など、表示用。タイムゾーン考慮済み
└── getInternalEpoch()    ← 内部の計算・ソート用。タイムゾーン未考慮、表示用ではない
```

- **使う側**：レポート画面に「対象日」を表示したい。
- **知らないこと**：`getInternalEpoch()` が UTC などの内部値で、そのまま表示するとタイムゾーンがおかしくなること。

##### 何が起きるか

- 「日付を取る」という意味で `getInternalEpoch()` を選び、それをそのまま文字列化して画面に出してしまう  
- 結果：日本ユーザーに、9時間ずれた日時が表示される。「なぜか日付がおかしい」と気づくまで時間がかかる。

**「"中身が分からない"まま、用途の違うメソッドを"表示用"に使ってしまう」** 例です。

---

#### 共通する「怖さ」の正体

| 怖いポイント | 例で起きていたこと |
|-------------|-------------------|
| ソースや意図が分からない | どのメソッドが「表示用」「内部用」「新規では使うな」か分からない |
| 知らずに間違える | 補完に出るからと、危険な方や用途違いのメソッドを使ってしまう |
| チームで共有しづらい | 「getSubtotal は表示に使うな」が口頭やコメントだけだと、新人や他チームに伝わらない |
| 後から変えにくい | 「使うな」なメソッドを削除・変更すると、知らない誰かが使っていて障害になる |

---

#### 実務でよくやる「安全な設計」

##### 1. アクセス修飾子で「使えない」にする

```java
// 悪い例：全部 public で、「使うな」はコメントだけ
public class Order {
    public int getTotalPrice() { ... }   // 使ってよい
    public int getSubtotal() { ... }     // 表示に使うな ← コメントは忘れられる
}

// 良い例：外に出すものを分ける
public class Order {
    public int getTotalPrice() { ... }   // 公開API。これだけ見える
    private int getSubtotal() { ... }    // 内部用。外からは呼べない
}
```

- **`private`** にすれば、**外からは存在すら使えない**ので、「知らずに使ってしまう」が防げる。

##### 2. インターフェースで「使っていいもの」をはっきりさせる

```java
// 外部向けには「これだけ使ってよい」と契約をはっきりさせる
public interface OrderForDisplay {
    int getTotalPrice();  // これだけ。getSubtotal は含めない
}
```

- 使う側は `OrderForDisplay` だけ知っていればよく、内部に `getSubtotal()` があっても、型として触れなければ間違いにくい。

##### 3. 命名で「使うな」を伝える（最終手段）

```java
// やむを得ず残す場合
@Deprecated
public int getRawAmount() { ... }  // 非推奨。IDE で取り消し線や警告

// または "internal" などを付けて、意図を伝える
public int getSubtotalInternal() { ... }
```

- あくまで**補助**。`private` で出さない方が確実。

---

#### 初学者向けのまとめ

- **「存在するけど使っちゃダメ」がたくさんあるクラスは、中身や意図が分からない人が、知らずに間違ったメソッドを選びやすい。** これが「怖くて使えない」の主な理由です。
- 実務では、**使っていいものだけ `public` で出し、それ以外は `private` で隠す**、**インターフェースで「契約」をはっきりさせる**、といった設計にします。
- そうすると、**「見えている＝使ってよい」** になり、ソースの詳細を知らなくても、安全にクラスを使えるようになります。
