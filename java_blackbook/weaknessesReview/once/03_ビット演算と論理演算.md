# 復習：ビット演算と論理演算の違い（問12）

## 間違えた理由

- 空欄には「**ビット演算**」が入るのに、**論理演算子 &&**（C）を選んでしまった。
- 「0 が true だと…」のように、**論理演算とビット演算が混ざった考え方**になっていた。
- 設問では `(status _____ FLAG_C) != 0` の形で、**int 同士の演算結果を 0 と比較**しているため、ここで使えるのは **ビット演算子 &, |, ^** のいずれか。&& は boolean 用なので式の型として不適切。

---

## 重要なポイント

### 1. ビット演算子と論理演算子の使い分け

| 種類 | 演算子 | オペランドの型 | 結果の型 | 用途 |
|------|--------|----------------|----------|------|
| **ビット演算** | `&` `|` `^` | int など整数型 | int（同じ型） | ビットパターンの操作、フラグ判定 |
| **論理演算** | `&&` `\|\|` | boolean | boolean | 条件の AND/OR、ショートサーキット |

- `(status _____ FLAG_C) != 0` のように **整数の式** なら → **ビット演算子**（&, |, ^）。
- **条件式**（if の条件など）で true/false を組み合わせるなら → **論理演算子**（&&, ||）。

### 2. 結果を 0 にしたいとき（問12の意図）

- status = 0b1011、FLAG_C = 0b0100 のとき、
  - **AND (&)** : 1011 & 0100 = **0000** → 0
  - OR (|)  : 1011 | 0100 = 1111 → 0 にならない
  - XOR (^) : 1011 ^ 0100 = 1111 → 0 にならない

- result を **false** にしたい → `(status _____ FLAG_C) != 0` が **false** → 演算結果が **0** である必要がある。
- 両方 1 のビットだけ 1 になる **AND (&)** を使う。FLAG_C のビットが status に無いので、結果は 0。

### 3. 覚え方

- **ビット演算**：整数のビット列を操作。結果も整数。`&` は「両方 1 のときだけ 1」。
- **論理演算**：boolean の true/false を組み合わせる。結果は boolean。`&&` は「両方 true のときだけ true」。
- 式のオペランドが **数値（int など）** なら & / | / ^、**boolean** なら && / || と切り分ける。
