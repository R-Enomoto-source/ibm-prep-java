# Chapter3 復習ポイント（1回目）

第3章「演算子と制御構造」で間違えた問題の理由と、各分野の重要なポイントをまとめています。

---

## 1. インクリメント・デクリメント（問3）

### 間違えた理由

- **計算結果は正しかったが、選択肢の対応を誤った**
  - 導出の最後に「32」と書いてあり、計算は 32 で合っていたが、選択肢を **C（33）** にしてしまった。
- 一時変数と評価順序の考え方は使えていたが、**「計算結果＝どの選択肢か」の最終確認**が抜けていた。

### 重要なポイント

- **後置**（`a++` / `a--`）：**元の値のコピー**を式の結果として返してから、変数の値を 1 増減する。
- **前置**（`++a` / `--a`）：**先に**変数の値を 1 増減してから、**その新しい値**を式の結果として返す。
- 1 つの式に複数の `++` / `--` があるときは、演算子が**出てきたタイミング**で一時変数を確定させ、それ以降の `a` には更新された値が使われる。
- 式の評価を終えたら、**求めた数値が選択肢のどれに相当するか**を必ず確認する習慣をつける。

---

## 2. equals のオーバーライドとオーバーロード（問10・問11）

### 間違えた理由

**問10**  
- Main では `Object a = new Sample(10);` のように**参照型が Object**。`a.equals(b)` で呼ばれるのは「**Object 型を引数に取る equals**」であり、Sample の `equals(Sample obj)` は**オーバーライドではなくオーバーロード**。Object の equals（同一性比較）が使われ、別インスタンスなので **false**。

**問11**  
- **null との比較はコンパイル可能**。Object の equals は `return (this == obj);` なので、`a.equals(null)` は **false** を返す。「x.equals(null) は false を返す」が equals の契約。

### 重要なポイント

- オーバーライドするには**引数が Object 型**でなければならない。`equals(Sample obj)` はオーバーロードで、参照型が Object のときは多態で呼ばれない。
- **x.equals(null) は常に false を返す**。コンパイルエラーにはならない。

---

## 3. ビット演算と論理演算の違い（問12）

### 間違えた理由

- 空欄には「**ビット演算**」が入るのに、**論理演算子 &&** を選んだ。`(status _____ FLAG_C) != 0` は **int 同士の演算**なので、使えるのはビット演算子 &, |, ^。&& は boolean 用。

### 重要なポイント

- **ビット演算**（`&` `|` `^`）：オペランドは int など整数型、結果も整数。フラグ判定など。
- **論理演算**（`&&` `||`）：オペランドは boolean、結果も boolean。条件の AND/OR。
- 結果を 0 にしたいとき（両方 1 のビットがないとき）は **AND (&)**。例：0b1011 & 0b0100 = 0000。

---

## 4. if の中カッコ省略（問14）

### 間違えた理由

- 中カッコを省略したときに **「直後の 1 文だけ」が if に属する** というルールを適用していなかった。5 行目は if の外なので常に実行され、「B」のみ表示が正解。

### 重要なポイント

- **if の直後の 1 文だけ**が、条件が true のときに実行される。それ以降の文は if とは無関係で常に実行される。
- 中カッコを補ったコードに書き直して、どこまでが if に属するかを確認するとよい。

---

## 5. switch の型と case（問17・問18）

### 間違えた理由

**問17**  
- switch の条件式に **long は使えない**。**enum は使える**。E（long）を外し、G（enum）を入れる必要があった。

**問18**  
- エラーになるのは **8 行目（case に変数 num）**。10 行目は `case 2*5` でコンパイル時に決まる定数式なのでエラーにならない。case には**コンパイル時に値が決まる定数**かリテラルが必須で、変数は不可。

### 重要なポイント

- switch で使える型：**char, byte, short, int** とそのラッパー、**String, Enum**。**long・boolean・浮動小数点型は不可**。
- **case の値**：定数またはコンパイル時に決まる定数式。**変数は不可**。final 定数やリテラル、`2*5` のような定数式は可。

---

## 6. switch 式（問22）

### 間違えた理由

- switch **式**では、すべての値のパターンが網羅されていないと**コンパイルエラー**。int の score/10 は 0〜10 など広い範囲なので case だけでは網羅できず、**default が必須**。実行時の評価の話ではなく、コンパイル段階で弾かれる。

### 重要なポイント

- **switch 式**では「すべてのパターンが網羅されていること」が求められる。int のような広い型では **default を書かないとコンパイルエラー**。
- switch 文では default は省略可能だったが、switch 式では網羅性のため default が欠かせない場合がある。

---

## 7. for の初期化・条件（問28・問31）

### 間違えた理由

**問28**  
- for の初期化で `int i = 1, long j = 2` のように**異なる型**をカンマで並べることはできない。**同じ型に限られる**。コンパイルエラーが正解。

**問31**  
- for の**条件式は 1 つだけ**。`i < 3, j < 5` のようにカンマで複数書くことはできない。複数条件にしたい場合は && や || で 1 つの式にする。

### 重要なポイント

- **初期化**：同じ型の変数をカンマで複数宣言・初期化できる。**異なる型は不可**。
- **条件**：**1 つの式のみ**。カンマで並べられるのは**初期化と更新**だけ。条件は 1 つ。

---

## 8. 拡張 for と参照（問37）

### 間違えた理由

- 拡張 for の `str` は「**配列要素の参照のコピー**」。`str = "D"` は**そのコピー変数**の参照を差し替えているだけで、**配列の要素**は変わらない。表示されるのは元の "A","B","C" のまま（「ABC」が正解）。

### 重要なポイント

- 拡張 for の変数に**別の参照を代入**しても、配列・コレクションの内容は変わらない。代入しているのは「ループ変数」の参照先だけ。
- 要素オブジェクトの**フィールドを変更**するような場合は、配列側にも反映される（同じインスタンスを指しているため）。

---

## 9. do-while と等価な while（問38）

### 間違えた理由

- 元コードは do-while で、まず 1 回実行して num++ で 11、その後 while(++num < 10) で ++num が 12 になり 12 < 10 は false で終了、表示は 12。A〜D の while 版はいずれもこの「1 回実行してから 12 で終了」とは異なる動きになるため、正解は「すべて誤り」の E。

### 重要なポイント

- **do-while**：最低 1 回実行してから条件判定。**while**：最初に条件判定。
- 同じ動きにしようとすると、条件判定のタイミングや前置/後置インクリメントの影響で、単純な while では再現できないことがある。選択肢を 1 つずつトレースして、元の「表示結果・回数」と一致するか確認する。

---

## 10. 二重ループと break（問40）

### 間違えた理由

- 外側の for は array = {"A","B"} で **2 回**まわる。内側で b が "B" のときに break するので、**外側 1 回目**で "A" を表示して break、**外側 2 回目**でも "A" を表示して break となり、結果は「**AA**」。break が抜けるのは**内側ループだけ**なので、外側は 2 回とも回り、そのたびに内側で "A" が 1 回ずつ表示される。

### 重要なポイント

- **break** が抜けるのは**直近の（内側の）ループ**だけ。外側のループは継続する。
- 二重ループで内側だけ break する場合、**外側の回数分だけ「内側の 1 回分の処理」が実行される**と考える。

---

## 11. ラベルの付けられる場所（問42）

### 間違えた理由

- ラベルは if/switch だけでなく、**式・代入・return 文・try ブロック**などにも付けられる。「A〜E すべて」が正解（F）。「if と switch だけ」は誤り。

### 重要なポイント

- ラベルは**多くの文・ブロック**に付けられる。ループ・if/switch・式・代入・return・try・throw など。制御が飛ぶ先を明示するために使う。使いすぎは可読性を下げるので注意。

---

## 12. ラベル付き continue/break のトレース（問43）

### 間違えた理由

- i が**偶数のとき**は `continue a` で外側ループの次回へ行くので、**その回の内側ループは一切実行されない**。i が**奇数のとき（1, 3）だけ**内側が回り、j が 0,1,2,3 のうち 3 より大きくなったら `break b` で内側だけ抜ける。i=1 のとき total に 0+1+2+3=6、i=3 のときも 6 加算され、**total は 12**。

### 重要なポイント

- **continue ラベル**：そのラベルのループの「次の反復」へ進む。その回の内側ループは実行されない。
- **break ラベル**：そのラベルのループを抜ける（ここでは内側だけ）。
- どの i で内側が実行され、どこで break するかを**表に整理**すると、加算結果が 12 になることが確認できる。
