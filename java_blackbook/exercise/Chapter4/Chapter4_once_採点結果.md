# Chapter4 練習問題 採点結果

## 概要

| 項目 | 結果 |
|------|------|
| **正答数** | 25 / 40 問 |
| **得点率** | 62.5% |
| **〇（正解）** | 25 問 |
| **✕（不正解）** | 15 問 |

---

## 問別 採点・導出過程のコメント

### 正解した問題（考え方の評価）

| 問 | 解答 | 正誤 | 導出過程のコメント |
|----|------|------|---------------------|
| 1 | B | 〇 | **考え方◎** 1つ目のインスタンスの num は初期値10のままであること、2つ目だけ setNum で20になることを正しく理解しています。 |
| 2 | B | 〇 | **考え方◎** 「参照の代入で a と b が同じ参照先を示す」という理解は正しく、解説と一致しています。 |
| 3 | F | 〇 | **考え方◎** null は小文字のみで「NULL」は不可、という点を自分で整理して F に修正できています。 |
| 4 | B | 〇 | **考え方◎** 一度「c は a を参照している」と気づき、3行目のインスタンスは c から参照されているため GC 対象は1つのみ、と正しく修正しています。 |
| 5 | C | 〇 | **考え方△** 正答は C。static フィールドは「クラス名.フィールド名」でインスタンスなしにアクセスできる点を、解説で再確認するとよいです。 |
| 6 | DE | 〇 | **考え方◎** 「static メソッドからは static メンバにしかアクセスできない」と本質を押さえ直し、D・E に修正できています。 |
| 7 | E | 〇 | **考え方◎** インスタンスメソッドは「参照.メソッド名()」で呼ぶこと、クラス名での呼び出しと混同しないように整理できています。 |
| 8 | D | 〇 | **考え方◎** 引数が1つしか渡されていないのに、2つ受け取る add が定義されているためコンパイルエラー、というシグニチャの一致の理解は正しいです。 |
| 9 | AB | 〇 | **考え方◎** 「宣言・作成されていない変数は使えない」という順次処理とローカル変数のルールを正しく使えています。 |
| 10 | E | 〇 | **考え方◎** void で戻り値なしなら return で値を返してはいけない、D は戻り値型が String でないとダメ、という整理は正しいです。 |
| 11 | A | 〇 | **考え方◎** void の setValue の戻り値を変数に代入しようとするとコンパイルエラー、という理解で正しいです。 |
| 12 | BC | 〇 | **考え方◎** 戻り値が float なので、float および互換な double で受け取れる、という型の互換性の理解は正しいです。 |
| 13 | C | 〇 | **考え方◎** 引数1つで呼んでいるが、メソッドは2つ要求しているためコンパイルエラー、という理解は正しいです。 |
| 16 | BD | 〇 | **考え方◎** オーバーロードは「引数の数・型・順番」が異なることが条件で、戻り値だけ・変数名だけの違いはオーバーロードにならない、と正しく理解しています。 |
| 18 | E | 〇 | **考え方◎** アクセス修飾子はオーバーロードの条件に含まれず、シグニチャが同じならコンパイルエラー、という理解は正しいです。 |
| 19 | D | 〇 | **考え方◎** コンストラクタには public / protected / デフォルト / private のいずれでも修飾できる、という理解で正しいです。 |
| 20 | A | 〇 | **考え方◎** 戻り値型があるとコンストラクタではなく通常メソッドになるため、デフォルトコンストラクタが使われ「hello.」が1回、という流れは正しいです。 |
| 24 | B | 〇 | **考え方◎** 同クラス内の別コンストラクタを呼ぶには this() を使う、という理解は正しいです。 |
| 26 | D | 〇 | **考え方◎** 別パッケージの子クラスから、修飾子なし（パッケージ private）のフィールドに super なしで直接アクセスできない、という点を押さえています。 |
| 28 | A | 〇 | **考え方◎** プリミティブは値渡しなので、メソッド内で引数を変更しても呼び出し元の s.num は 10 のまま、という理解は正しいです。 |
| 29 | B | 〇 | **考え方◎** 参照がコピーされて渡るため、同じインスタンスが変更され、表示は 20 になる、という参照渡しの理解は正しいです。 |
| 30 | E | 〇 | **考え方△** 正解は E。else ブロックで使われる b はパターン変数ではなくフィールドの b になる、というスコープの話です。理由は「instanceof のパターン変数のスコープ」で復習するとよいです。 |
| 33 | D | 〇 | **考え方◎** レコードは構成要素と同じ引数を持つコンストラクタが暗黙で定義され、引数なしコンストラクタはない、という理解で正しいです。 |
| 37 | C | 〇 | **考え方◎** レコードのコンストラクタは、レコード自体より厳しいアクセス修飾子にできない、という理解で正しいです。 |
| 38 | D | 〇 | **考え方△** 正解は D。引数なしコンストラクタからは this("sample") のように標準コンストラクタを呼ぶ必要がある、という点を解説で確認するとよいです。 |

---

### 不正解だった問題（正解・考え方のポイント）

| 問 | あなたの解答 | 正解 | 導出過程のコメント |
|----|-------------|------|---------------------|
| **14** | B | **G** | 可変長引数の「...」は**型の直後**に書きます。B は変数名の後ろに「...」があるため誤りです。また、可変長引数は**最後の引数**でなければならないため、C・D も誤り。設問では正しいものが一つもないため、正解は G（どれも正しくない）です。 |
| **15** | B | **C** | コンパイルエラーになるのは「到達不可能なコード」があるためです。return の**後ろ**に書かれた処理は実行されないため、コンパイラがエラーにします。5行目ではなく、return の後の行が問題です。 |
| **17** | D | **A** | 2 と 3 は int リテラルで、double を受け取る両方のオーバーロードに暗黙変換で当てはまります。そのため「どちらのメソッドを呼ぶか決められない」**あいまいなメソッド呼び出し**でコンパイルエラーになります。正解は A です。 |
| **21** | C | **B** | **初期化子はコンストラクタより先に実行**されます。そのため実行順は「初期化子（B を表示）→ コンストラクタ（A を表示）」で、出力は「B」「A」の順、正解は B です。 |
| **22** | D | **A** | インスタンスを**生成していない**ため、初期化子もコンストラクタも実行されません。static でない num の初期化は行われず、クラス変数 num は**デフォルト値の 0** のまま。表示は 0 で、正解は A です。 |
| **23** | A | **D** | クラス名と同じ名前のメソッドに**戻り値型が書いてある**ため、それはコンストラクタではなく通常メソッドです。引数ありコンストラクタだけが定義され、**デフォルトコンストラクタは追加されない**ため、引数なしの `new Sample()` はコンパイルエラー。正解は D です。 |
| **25** | A | **E** | **this() で別コンストラクタを呼ぶ場合は、コンストラクタの先頭でなければなりません**。`System.out.println("A");` の後に `this("B");` があるため、先頭でないのでコンパイルエラー。正解は E です。 |
| **27** | B | **C** | printInfo は **protected** です。Main は Book を継承しておらず、かつ別パッケージの可能性もあるため、Main から printInfo を呼べません。継承していても「Main から」呼べるかはアクセス制御で決まります。正解は C です。 |
| **31** | E | **B** | レコードは **final** であり、サブクラスを作れません。したがって「レコードを継承したサブクラスを作れる」という説明が誤りで、正解は B です。toString / hashCode / equals は自動生成されます。 |
| **32** | AD | **AB** | トップレベルレコードに使えるアクセス修飾子は **public と なし（デフォルト）** だけです。A は正解。protected や private はトップレベルレコードには使えず、B がもう一つの正解です。D は誤りです。 |
| **34** | D | **C** | レコードでは **static ではないインスタンスフィールドを追加で宣言できません**。構成要素から自動生成されるフィールドのみ。static フィールドは宣言可能です。設問の正解は C（static でないフィールドは定義できない）です。 |
| **35** | C | **A** | レコードでは構成要素と**同じ名前**の getter が自動生成されます。メソッド名に get は付きません。したがって `data.value()` のように「フィールド名と同じ名前のメソッド」でアクセスするのが正しく、正解は A です。 |
| **36** | CE | **AC** | 代替コンストラクタでは**標準コンストラクタと同じ引数**を受け取り、**すべてのフィールドを初期化**する必要があります。正解は A と C。E（static でないフィールドの追加）はレコードではできません。 |
| **39** | A | **C** | **コンパクトコンストラクタ**では、フィールドの初期化はまだ行われていません。そのため **this.xxx でフィールドを参照するとコンパイルエラー**になります。正解は C です。 |
| **40** | A | **C** | インタフェースのデフォルトメソッド value() は **void**、レコードの自動生成 getter value() は **String** を返します。シグニチャが同じでも戻り値型が違うとオーバーライドにならず、**コンパイルエラー**になります。正解は C です。 |

---

## 分野別の理解度（目安）

- **クラスとインスタンス・参照（1〜4）** … よくできています。
- **static（5〜7）** … 一度迷いながらも、static メソッド・フィールドの呼び出し方の違いを修正して理解できています。
- **メソッド・シグニチャ・戻り値（8〜15）** … 8〜13 は安定。14（可変長引数の構文・G）、15（到達不可能コード）は要復習。
- **オーバーロード（16〜18）** … 16・18 は良い。17 は「あいまいなメソッド呼び出し」のパターンを押さえるとよいです。
- **コンストラクタ・初期化子（19〜25）** … 19・20・24 は良い。21（初期化子の実行順）、22（インスタンス未生成時の static）、23（戻り値型付き＝通常メソッド）、25（this() は先頭のみ）を復習するとよいです。
- **アクセス制御・継承（26〜29）** … 26・28・29 は良い。27 は protected と「どこから呼べるか」を整理するとよいです。
- **instanceof・レコード（30〜40）** … 30・33・37・38 は正解。31（レコードは final）、32（トップレベルは public/デフォルト）、34（インスタンスフィールド追加不可）、35（getter の名前）、36（代替コンストラクタの条件）、39（コンパクトコンストラクタと this）、40（インタフェースと getter の戻り値型）を重点的に復習するとよいです。

---

## 復習のおすすめ

1. **可変長引数**（問14）… 「型の直後で ...」「最後の引数にのみ」を確認。
2. **return と到達不可能コード**（問15）… return の後の文は実行されないためコンパイルエラーになることを確認。
3. **オーバーロードと曖昧な呼び出し**（問17）… int が double に変換できる場合、複数候補に当てはまるとコンパイルエラーになることを確認。
4. **初期化子とコンストラクタの順序**（問21）… 初期化子 → コンストラクタの順で実行されることを確認。
5. **コンストラクタのルール**（問23・25）… 戻り値型があるとコンストラクタではないこと、this() は先頭のみであることを確認。
6. **レコード**（問31〜40）… final・構成要素と getter 名・static のみ追加可能・代替コンストラクタ・コンパクトコンストラクタと this の制限・インタフェース実装時の戻り値型を、解説と合わせて読み直すとよいです。

全体として、クラスとインスタンス・参照・メソッドの基本はよく身についており、迷った問題でも「参照渡し」「void と戻り値」「オーバーロードの条件」などで自分で修正できている場面が多くあります。上記の復習ポイントを押さえると、さらに得点と理解が安定すると思います。
