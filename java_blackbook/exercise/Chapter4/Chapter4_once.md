1.  B　〇
    2行目で10で初期化されているフィールドのnumをgetNum()で呼び出しているから。初期値が10だから。
2.  B　〇
    参照渡しで、bの~~持つnameとprice~~インスタンスの参照先の情報がaに渡されるから。つまり、aとbは同じ参照先を示すことになるから。
3.  C　✕　F　〇
    文法的にnullを大文字で書くことが許されているのであれば、大文字のNULLを表示したければ、Cと書くしかないのではないか。許されていないのであれば、Fになる。
4.  B　〇
　  67行目で、どちらのabインスタンスも参照先がなく、値？がnullになってしまっていて、何も参照していないインスタンスになってしまっているためCが正解。
    だと思ったがcはaを参照しているため、3行目で作成されたインスタンスは参照先があるため削除されない。よってBが正解。    
5. D　✕　C　〇
    この書き方は文法として出来なかった気がするから。インスタンスを作成していないのに、値を入れることは出来ないのでは？フィールドの値をこの書き方で書き換えられるのであれば、Aが正解となると思われる。
6.  BC　✕　DE　〇
    基本的にstaticで修飾されているメソッドもフィールドも外部クラスからは呼び出せないため。正確な理解ではないと思われる。
7.  E
    正しい書き方であるのがDであるため。クラス名.メソッド名();が正しい呼び出し方。
    と思ったが、sampleインスタンスのhalloメソッドを呼び出しているため、Eが正解。インスタンス名.メソッド名();が正しい書き方。パッケージ名を各場合と混同したと思われる。
8.  D
    DかEだと思われる。多分D。書くべき引数を書いていないから。
9.  AB
    宣言および作成されていない変数は使用できないため。
10. D
    戻り値・返り値を返しているため。
    と思ったが返したいなら、戻りの型はString出ないとダメなのでDは間違っている。となると、戻り値を返しておらず、何も記述していないEが正解だと思われる。
11. A
    セッターで入れたことを変数に格納する、という書き方が文法的に出来ないとされているため。
    コンパイルエラーにならないとすると、F。これ以外はコンパイルエラーにならないと思われるため。valには何らかの情報が格納されていることを考えると、何かは表示されるはずで、それが選択肢にないということはコンパイルエラーになるのではないか。
12. B、C
    返している値がfloatなので、floatと自動型変換されるdoubleを選択した。
13. C
    引数を1つしか入力していないため。
    コンパイルエラーにならなければD。
14. B
    可変長引数の使い方として正しいのがBだけだと思われるため。
    そうでなければ、CDFのどれかが正しいのだと思われる。
15. B
    3行目はboolean型のtrueかfalseが入るから３行目はコンパイルエラーにならないのではないかと思ったが、メソッドの引数とそのメソッド内でのローカル変数であればコンパイルエラーにならないのではないかと思う。なので、返す値が何もない５行目がコンパイルエラーになるのではないか。
16. BD
    引数の種類や数を変えることでオーバーロードできたはず。そうではないBとDはオーバーロードしていない。
17. D
    6行目と9行目と自動型変換ができるので、4行目のリテラルだと、6行目と9行目のメソッドのどちらを使えばよいのか判別できないため、Dとなるのではないか。
18. E
    アクセス修飾子はオーバーロードとは関係なく、アクセス制御を行うために使うもの。違うアクセス修飾子をつけたとて、意味はないのではないか。
19. D
    どんなアクセス修飾子でも修飾出来た気がする。
20. A
    s.sampleで一度だけSampleを呼んでいるから。
21. C
    コンパイルエラーにならないと仮定して処理するとCが答えになるから。
22. D
    クラスのフィールドを直接呼び出すことは出来なかったような気がするから。
23. A
    Sampleインスタンスを作成する度に、Aを表示するコンストラクタが呼ばれているから。コンストラクタにvoidがつけられないとすれば、Dになるのではないか。
24. B
    同クラス内のコンストラクタを呼ぶために、this()を使うはず。
25. A
    コンストラクタが動作してまずAが表示される。次に、Bを引数にしたコンストラクタを呼んでいて、それが引数を表示するものだから、Bを表示する。
26. D
    内側のフィールドを呼ぶときにはsuper.をつけなければいけなかったと思うがつけられていないから。
27. B
    継承したメソッドは、継承先のクラスでメソッドを書かなくても、そのまま使えた気がするから。
28. A
    戻していないから、numが20になっただけで、s.numは10のままなのでは？
29. A
    変数sのスコープ範囲が違うため。この値を戻していないから。
30. B
    処理していったらこうなるのでは？どちらのぞろ目になると思う。
31. E
    正直よくわからない。
    hashCodeは定義されていなかった気がするから。
32. AD
    何となく。
33. D
    インスタンスを生成しているから。そうでないならＢ。
34. D　staticフィールド
    なんとなく。よくわかっていない。
35. C
    引数にString型をとっていないものBは排除、ないメソッドを使っているものDは排除、valueはメソッドではないため、Aを排除。残ったものがC。
36. CE
    使わないだろう選択肢を消していった消去法
37. C
    これまでの問題での使用傾向から
38. D
    なんとなく。正直分からない。
39. A
    処理していった結果。
40. A
    Testのvalueメソッドが継承されていて、Bが表示されると思ったが、String valueの場合に引数valueを表示するという処理がないため、Ａになると思われる。