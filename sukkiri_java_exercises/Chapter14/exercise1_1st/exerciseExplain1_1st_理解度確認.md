# 練習14-1 理解度確認

exerciseExplain1_1st.md の内容を理解できているか確認するための問題です。  
答えはファイルの末尾にあります。まずは自分で考えてから確認してください。

---

## 問題1：エスケープシーケンス

`toString()` メソッドで画面に「¥1592」と表示したいとき、ソースコードの文字列リテラルには何と書くべきですか？  
また、その理由を簡潔に答えてください。

---

## 問題2：equals() の目的

`Account` クラスの `equals(Object o)` メソッドで、引数 `o` が「口座と口座を比較する相手」かどうかを判定するために、`instanceof` でチェックすべき型は何ですか？  
（`String` と `Account` のどちらが正しいか、理由も含めて答えてください。）

---

## 問題3：instanceof の使い方

次のコードの（  ）に当てはまるクラス名を答えてください。  
口座番号が等しければ等価とみなす `Account` クラスの `equals()` の一部です。

```java
if (o instanceof （  ） a) {
    String an1 = this.accountNumber.trim();
    String an2 = a.accountNumber.trim();
    return an1.equals(an2);
}
```

---

## 問題4：String の不変性と trim()

次のコードには問題があります。何が間違っているか、そして正しくするにはどうすべきかを答えてください。

```java
String ob = " 4649";
ob.trim();  // 空白を除去したい
// このあと ob を使って比較している
```

---

## 問題5：== と equals() の違い

`equals()` メソッドの最初に `if (this == o) { return true; }` を書く理由を、次の2点で答えてください。

1. この `==` は何を比較しているか（参照か、値か）。
2. なぜこのチェックを先に行うとよいか（「おまじない」以外の理由で）。

---

## 問題6：equals() の標準パターン

正しい `equals()` の実装は、おおまかに次の3ステップで書けます。  
（  ）に当てはまる言葉を答えてください。

1. （  ）との比較（同じインスタンスなら true を返す）
2. （  ）チェック（同じクラスかどうか。`instanceof` を使う）
3. （  ）の比較（口座番号を trim してから equals で比較）

---

## 問題7：コードの正誤

次の `equals()` メソッドには誤りがあります。誤っている箇所を指摘し、正しく書き直してください。

```java
public boolean equals(Object o) {
    if (this.accountNumber == o) {
        return true;
    }
    if (o instanceof String ob) {
        ob.trim();
        if (this.accountNumber.equals(o)) {
            return true;
        }
    }
    return false;
}
```

---

## 問題8：else を書かない理由

正しい解答では、`else` を使わずに最後に `return false;` としています。  
この書き方の利点を、次の観点から1つずつ簡潔に答えてください。

1. コードの長さ
2. ネスト（入れ子）の深さ
3. `return false` の場所

---

# 解答

<details>
<summary>クリックして解答を表示</summary>

## 問題1の解答

**答え：** `"¥¥"` と書く（円記号を2つ並べる）。

**理由：** Java の文字列リテラル内で円記号 `¥` は特殊な意味を持つため、そのまま `"¥"` と書くとエスケープとして解釈される。実際に「¥」という1文字を表示したいときは、エスケープシーケンス `¥¥` で「円記号1つ」を表す必要がある（書籍 p67）。

---

## 問題2の解答

**答え：** `Account`（クラス名が `bankAccount` の場合は `bankAccount`）。

**理由：** `equals()` は「同じクラスのインスタンス同士」が等しいかを判定するメソッドだから。口座と口座を比べるので、引数 `o` が口座（Account）かどうかを `instanceof Account` でチェックする。`String` は口座ではないので、ここではチェックしない。

---

## 問題3の解答

**答え：** `Account`（クラス名が `bankAccount` の場合は `bankAccount`）。

`o` は「もう一つの口座」として渡される想定なので、`instanceof Account a` で「o が Account かどうか」を判定し、同時に変数 `a` として扱う。

---

## 問題4の解答

**問題点：** `trim()` は**新しい文字列を返す**だけで、元の文字列 `ob` は変更しない（String は不変）。そのため `ob.trim();` の結果をどこにも代入しておらず、空白を除いた結果が使われていない。

**正しい書き方：**
```java
String ob = " 4649";
String trimmed = ob.trim();  // 戻り値を変数に代入する
// このあと trimmed を使って比較する
```

---

## 問題5の解答

1. **何を比較しているか：** **参照**の比較。`this` と `o` が「同じ1つのインスタンスを指しているか」を `==` で調べている。
2. **なぜ先に行うか：** 自分自身との比較は常に等しいので、その場合は中身のフィールドを比較する必要がなく、無駄な処理を省けるため。また、よく使われるパターンなので、最初に書いておくと読みやすい。

---

## 問題6の解答

1. **自分自身**（または「this と o」）
2. **型**（または「クラス」）
3. **フィールド**（または「口座番号」）

---

## 問題7の解答

**誤っている箇所：**

1. `this.accountNumber == o` … 比較すべきなのは「口座同士」なので `this == o` であるべき。`this.accountNumber` は String であり、`o` は Object（口座）なので、この比較は意味が違う。
2. `o instanceof String ob` … 口座同士を比較するので、`o instanceof Account a`（または `bankAccount a`）であるべき。
3. `ob.trim();` … `trim()` の戻り値を変数に代入していない。`String an2 = ob.trim();` のようにする必要がある（ただし `ob` は口座なので口座番号は `a.accountNumber`。設問の誤りを正すなら、`a.accountNumber.trim()` の結果を変数に代入する）。
4. `this.accountNumber.equals(o)` … 比較すべきなのは「口座番号の文字列同士」。`o` は Account なので、`an1.equals(an2)` のように、trim した口座番号同士を比較する。

**正しく書き直した例：**
```java
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o instanceof Account a) {
        String an1 = this.accountNumber.trim();
        String an2 = a.accountNumber.trim();
        if (an1.equals(an2)) {
            return true;
        }
    }
    return false;
}
```

---

## 問題8の解答

1. **コードの長さ：** else を書かないと、`return false` が1か所で済むため、全体が短くなる。
2. **ネストの深さ：** else を書かないと if の入れ子が浅く（フラットに）なり、読みやすい。
3. **return false の場所：** else を書くと「どの else で false を返すか」が複数に分散するが、書かないと「true にならなかった場合に最後に1回だけ false」と分かりやすい。

</details>

---

# 採点結果

## 総合評価

| 問題 | 配点 | 得点 | コメント |
|------|------|------|----------|
| 問題1 | 2 | 2 | ◎ 正解 |
| 問題2 | 2 | 1 | △ 誤字あり（Acount→Account）|
| 問題3 | 1 | 1 | ◎ 正解 |
| 問題4 | 2 | 2 | ◎ 正解 |
| 問題5 | 2 | 2 | ◎ 正解 |
| 問題6 | 3 | 2 | △ 表現の違いで部分点 |
| 問題7 | 3 | 2 | △ 一部誤りあり |
| 問題8 | 3 | 2 | △ 3番のみやや不十分 |
| **合計** | **18** | **14** | |

## 採点の詳細

### 問題1：エスケープシーケンス 【2/2点】◎
- `¥¥1592` の記述は正しい（円記号をエスケープして表示するため）。
- 理由も「特殊文字を文字列にする場合は前に \ を入れてエスケープする必要がある」と正しく理解できている。

### 問題2：equals() の目的 【1/2点】△
- **誤字：** 「Acount」→ 正しくは「**Account**」。
- 理由の内容（Accountのフィールドを比較する、instanceofでチェックする）は正しいが、クラス名の誤字のため減点。

### 問題3：instanceof の使い方 【1/1点】◎
- `Account` と正しく答えられている。

### 問題4：String の不変性と trim() 【2/2点】◎
- `ob.trim()` の戻り値を変数に代入していないことが問題であることを正しく指摘。
- `String ban = ob.trim();` のように正しい修正案も提示できている。

### 問題5：== と equals() の違い 【2/2点】◎
- 1. 参照の比較であることを正しく説明。
- 2. 参照先が同じなら値も同じだから、という理由も妥当。

### 問題6：equals() の標準パターン 【2/3点】△
- 1. 「thisとOの参照（==）」→ 正解は「自分自身」や「this と o」。内容は合っているが、`O` は小文字 `o` であるべき。意味は通じるので部分点。
- 2. 「キャストできるか否かの」→ 正解は「型」や「クラス」。instanceof は型チェックであり、キャスト可能性と関連はあるが、問題で求める「同じクラスかどうか」の観点からは「型」がより適切。
- 3. 「thisとoの値（.equals()）」→ 正解は「フィールド」や「口座番号」。値の比較という意味は通じるが、「フィールド」の比較であることがより正確。

### 問題7：コードの正誤 【2/3点】△
- `this.accountNumber == o` → `this == o` への修正は正しく指摘。
- `instanceof Account a` への修正、`an1`・`an2` を使った正しい比較も書けている。
- ただし、正しいコード例では冒頭に `if (this == o) { return true; }` が含まれるべき。また、`return false;` が最終的に必要。全体の流れは理解できているが、完全な解答には至っていない。

### 問題8：else を書かない理由 【2/3点】△
- 1. 「短くなり、可読性が向上する」→ ◎ 正解に近い。
- 2. 「ネストが浅くなり、可読性が上がる」→ ◎ 正解。
- 3. 「if文の一番外側の } の直下」→ △ 正解は「true にならなかった場合に最後に1回だけ false を返す」という**意図・利点**を答える問題。場所の説明のみでは、なぜその配置がよいか（分散せず1か所で済む、分かりやすい）という観点が不足。

---

**総評：** 全体的に理解度は高く、equals() の実装や String の不変性、エスケープシーケンスについての理解が十分にできています。問題2の「Account」の誤字、問題6・7・8の細かい表現の差に気を付けると、さらに高得点が期待できます。

---

# 間違えたところから学ぶ重要ポイント

今回の採点で減点になったポイントを、**今後間違えないための知識**として整理しました。

---

## 1. クラス名のスペルミス（問題2で発生）

### 何が起きたか
「Account」を「**Acount**」と書いてしまった（`c` が1つ足りない）。

### なぜ重要か
- Java ではクラス名のスペルが1文字違うだけで**コンパイルエラー**になる
- 「Acount」というクラスが存在しなければ、`instanceof Acount` はそもそも動かない
- 実際のコードでは IDE が補完してくれるが、試験や手書きでは自分で確認する必要がある

### 覚えておくこと
| 正しい | 間違い | 覚え方 |
|--------|--------|--------|
| Account | Acount | 「Account」= 口座。「acc**ou**nt」と **ou** を意識 |
| instanceof | instaceof | 「instance **of**」で「～のインスタンス」 |

**対策：** よく使うクラス名は綴りを覚えておく。書いた後に必ず見直す。

---

## 2. equals() の3ステップを「正しい用語」で理解する（問題6で発生）

### 何が起きたか
内容は合っているのに、用語の選び方で部分点になった。

### 正しい用語とその意味

| ステップ | 求める答え | よくある誤答 | なぜ「正しい用語」が大事か |
|----------|------------|--------------|----------------------------|
| 1 | **自分自身**（または「this と o」） | 「thisとOの参照（==）」 | 「自分自身との比較」という**目的**を表す。== は手段であって、ステップの名前ではない。また `O` は大文字なので別の変数に見える。小文字 `o` が引数 |
| 2 | **型**（または「クラス」） | 「キャストできるか否か」 | instanceof は「同じ型かどうか」をチェックする。キャストできるかどうかは**結果**であり、チェックの**目的**は「型が合っているか」 |
| 3 | **フィールド**（または「口座番号」） | 「thisとoの値」 | 比較しているのは「値」そのものではなく、**オブジェクトが持つフィールド（口座番号）**。equals() は「何を比較するか」が重要なので、「フィールド」と答えると正確 |

### 覚えておくこと

```
equals() の標準パターン
┌─────────────────────────────────────────┐
│ 1. 自分自身との比較  → 同じなら true    │
│ 2. 型チェック       → 違う型なら false │
│ 3. フィールドの比較 → 中身が等しいか   │
└─────────────────────────────────────────┘
```

---

## 3. equals() のコードは「最後まで書く」（問題7で発生）

### 何が起きたか
修正したコードの流れは正しいが、**最終的な `return false;`** と、冒頭の **`if (this == o) { return true; }`** が抜けていた。

### なぜ重要か

`equals()` は **boolean** を返すメソッドなので、**すべてのパスで return する**必要がある。

```java
public boolean equals(Object o) {
    if (this == o) {
        return true;   // ← 忘れやすい①：自分自身なら即 true
    }
    if (o instanceof Account a) {
        String an1 = this.accountNumber.trim();
        String an2 = a.accountNumber.trim();
        if (an1.equals(an2)) {
            return true;
        }
    }
    return false;      // ← 忘れやすい②：どの if にも該当しなかったら false
}
```

### 覚えておくこと

| 忘れやすい箇所 | 役割 | 忘れるとどうなるか |
|----------------|------|---------------------|
| `if (this == o) return true;` | 同じインスタンスなら無駄な処理を省く | 動くが、自分自身との比較で不要な処理をする |
| `return false;` | それ以外のすべてのケースで false | **コンパイルエラー**（return がないパスが残る） |

**対策：** equals() を書いたら、「true を返すケース」と「false を返すケース」の両方が網羅されているか確認する。

---

## 4. 「場所」ではなく「利点・意図」を答える（問題8-3で発生）

### 何が起きたか
「return false の場所は if文の一番外側の } の直下」と答えた。  
→ 正解は「**なぜその書き方にするか**」の説明を求める問題だった。

### 問われていることの違い

| 聞かれ方 | 答えるべきこと | 例 |
|----------|----------------|-----|
| 「return false はどこに書く？」 | **場所** | 「if文の一番外側の } の直下」 |
| 「return false を最後に1回にまとめる利点は？」 | **意図・利点** | 「分散せず1か所で済むので、false を返す条件が分かりやすい」 |

### 正しい答えのポイント

else を書かないと：

- **else を書いた場合**：`if (...) { ... } else if (...) { ... } else { return false; }` のように、false を返す場所が複数になりうる
- **else を書かない場合**：どの if にも該当しなかった場合に、**最後に1回だけ** `return false;` でまとめて処理できる

→ 利点は「**false を返す条件が1か所に集約され、読みやすい**」ということ。

### 覚えておくこと

問題で「利点」「理由」「なぜ」と聞かれたら、**場所や手順**ではなく、**その書き方によって得られる効果**を答える。

---

## まとめ：次回のテストで気を付けること

1. **クラス名のスペル**：Account、instanceof など、よく使う単語は正確に書く
2. **用語の選択**：equals() の3ステップは「自分自身」「型」「フィールド」で覚える
3. **コードの completeness**：equals() を書いたら `if (this == o)` と `return false` を忘れていないか確認
4. **問題の意図を読む**：「利点」「理由」を聞かれたら、効果・意図を答える
